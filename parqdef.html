
<!doctype html>

<html lang='en'>
<meta charset='utf-8'>
<title>Parquet Definition</title>
<meta content='D3 parquet deformation creator.' name='description'>
<style>
  
  path.edge {
    stroke: black;
    stroke-width: 0.05;
    fill: none;
  }

  path.protoedge {
    stroke: #444;
    stroke-width: 0.04;
    fill: none;
  }
  path.protoedge.active {
    stroke: blue;
    cursor: copy;
  }

  circle.anchor {
    fill: black;
    r: 0.06;
  }

  circle.cpoint {
    stroke-width: 0.025;
    stroke: black;
    fill: gray;
    r: 0.07;
  }
  circle.cpoint.active {
    stroke: #c00;
    fill: #f90;
  }

  circle.vertex {
    stroke-width: 0.025;
    stroke: #00a;
    fill: #88f;
    cursor: move;
    r: 0.07;
}

</style>
<body>  
  <svg id='main'>
    <g id='drawing'></g>
    <g id='controls'></g>
  </svg>
  
  <script src='http://d3js.org/d3.v4.js'></script>
  <script src="https://d3js.org/d3-drag.v1.js"></script>
  <script src='https://d3js.org/d3-array.v1.min.js'></script>
  <script src='https://d3js.org/d3-shape.v1.min.js'></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>

  <script>

    /*****************\
    |*               *|
    |*  SCAFFOLDING  *|
    |*               *|
    \*****************/

    var svg, drawing, controls // defined by init
    var shouldRedraw = false
    var cmoved = false
  
    var nw = 23, nh = 11
    var border = 30, width = 1200, controlHeight = 150, controlWidth = width/controlHeight
    var scale = (width - border*2)/(1.5*nw), height = scale*nh + controlHeight + border*3
    
  
    const edgeHelper = d3.line()

    var prototiles // defined by restart
    var parqLocs // defined by reparameterize
    var parqElements, edgeElements // defined by rerender
    var edgeGenerator // defined by rerender AND reupdate

    var prototileElements, ptEdgeElements, ptCpointElements, ptAnchorElements,
      ptVertexWrappers, ptVertexElements // defined by rerenderControls

    var edgeTfs // defined by many things

    const rt3 = Math.sqrt(3)
    const third = 1/3

    // note: inconsistent use of arrow functions and `function()` functions, because I prefer arrow functions in
    // compact definitions like this, but sometimes can't be used because their `this` can't be rebound
    const wallpapers = {
      p1: {
        square: function() {
          this.cpoint = [1, 1] // control point. in the future may be variable between tiles
          this.cmove = (x,y) => [1, 1]; this.cmove.cursor = 'default' // how the cpoint changes if it is dragged to x,y
          this.anchors = function () {return [[0, 0], [1, 0], this.cpoint, [0, 1]]} // corners
          this.edgeEnds = [
            [1, 2], // values are indices of this.anchors
            [2, 3]  // if variable cpoints implemented, will instead be indices of tile.anchors
          ]
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', 'translate(0 -1)']]
          this.tf = d => `translate(${d.nx} ${d.ny})`
        },
        rectangular: function() {
          Object.assign(this, new wallpapers.p1.square())
          this.cmove = (x,y) => [x,1]; this.cmove.cursor = 'ew-resize'
          this.anchors = function () {return [[0, 0], [this.cpoint[0], 0], this.cpoint, [0, 1]]}
          this.edgeTfs = () => [['', `translate(-${this.cpoint[0]} 0)`], ['', 'translate(0 -1)']]
          this.tf = d => `translate(${this.cpoint[0]*d.nx} ${d.ny})`
        },
        oblique: function() {
          Object.assign(this, new wallpapers.p1.square())
          this.cmove = (x,y) => [x,y]; this.cmove.cursor = 'move'
          this.anchors = () => [[0, 0], [1, 0], this.cpoint, [this.cpoint[0]-1, this.cpoint[1]]]
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', `translate(${1-this.cpoint[0]} -${this.cpoint[1]})`]]
          this.tf = d => `translate(${d.nx + (this.cpoint[0]%1)*d.ny} ${this.cpoint[1] * d.ny})`
        },
        hexagonal: function() {
          this.cpoint = [Math.sqrt(3), 0.5]
          this.cmove = (x,y) => [this.cpoint[0],0.5]; this.cmove.cursor = 'default'
          this.anchors = function () {return [[0, 0.5], [this.cpoint[0]/2, 0], this.cpoint, [this.cpoint[0]/2, 1]]}
          this.edgeEnds = [[1, 2], [2, 3]],
          this.edgeTfs = () => [['',`translate(-${this.cpoint[0]/2} 0.5)`],['',`translate(-${this.cpoint[0]/2} -0.5)`]]
          this.tf = d => `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2})`
        },
        rhombic: function() {
          Object.assign(this, new wallpapers.p1.hexagonal())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      p2: {
        square: function() {
          this.cpoint = [1,1]
          this.cmove = (x,y) => [1,1]; this.cmove.cursor = 'default'
          this.anchors = () => [[0, 0], [0.5, 0], [1, 0], [1, 0.5], [1, 1], [0.5, 1], [0, 1], [0, 0.5]]
          this.edgeEnds = [[0,1],[2,3],[4,5],[6,7]]
          this.edgeTfs = function () {let a = this.anchors(); return Array.from({length:4}, (e,i) => ['', `rotate(180 ${a[i*2+1]})`])}
          this.tf = d => `translate(${d.nx} ${d.ny}) rotate(${(d.nx+d.ny)%2 * 180} 0.5 0.5)`
        },
        rectangular: function() {
          Object.assign(this, new wallpapers.p2.square())
          this.cmove = (x,y) => [x,1]; this.cmove.cursor = 'ew-resize'
          this.anchors = function () {let x=this.cpoint[0]; return [[0, 0], [x/2, 0], [x, 0], [x, 0.5], [x, 1], [x/2, 1], [0, 1], [0, 0.5]]}
          this.tf = d => `translate(${d.nx*this.cpoint[0]} ${d.ny}) rotate(${(d.nx+d.ny)%2 * 180} ${this.cpoint[0]/2} 0.5)`
        },
        oblique: function() {
          Object.assign(this, new wallpapers.p2.square())
          this.cmove = (x,y) => [x,y]; this.cmove.cursor = 'move'
          this.anchors = () => {let x=this.cpoint[0]; let y=this.cpoint[1];
            return [[0, 0], [0.5, 0], [1, 0], [x/2+0.5, y/2], [x, y], [x-0.5, y], [x-1, y], [(x-1)/2, y/2]]}
          this.tf = d => {let x=this.cpoint[0]; let y=this.cpoint[1];
            return `translate(${d.nx + (x%1)*d.ny} ${y*d.ny}) rotate(${(d.nx+d.ny)%2 * 180} ${x/2} ${y/2})`}
        },
        hexagonal: function() {
          this.cpoint = [Math.sqrt(3), 0.5]
          this.cmove = (x,y) => [this.cpoint[0],0.5]; this.cmove.cursor = 'default'
          this.anchors = function() {let x=this.cpoint[0];
            return [[0, 0.5], [x*0.25, 0.25], [x*0.5, 0], [x*0.75, 0.25], [x, 0.5], [x*0.75, 0.75], [x*0.5, 1], [x*0.25, 0.75]]}
          this.edgeEnds = [[0,1],[2,3],[4,5],[6,7]]
          this.edgeTfs = function() {a = this.anchors(); return Array.from({length:4}, (e,i) => ['', `rotate(180 ${a[i*2+1]})`])}
          this.tf = function(d) {console.log(this);return `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2}) rotate(${d.nx%2 * 180} ${this.cpoint[0]/2} 0.5)`}
        },
        rhombic: function() {
          Object.assign(this, new wallpapers.p2.hexagonal())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      pm: {},
      pg: {
        square_a: function() {
          Object.assign(this, new wallpapers.p1.square())
          this.edgeTfs = () => [['', 'translate(-1 1) scale(1 -1)'], ['', 'translate(0 -1)']],
          this.tf = d => `translate(${d.nx} ${d.ny+d.nx%2}) ${d.nx%2?'scale(1 -1)':''}`
        },
        square_b: function() {
          Object.assign(this, new wallpapers.p1.square())
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', 'translate(1 -1) scale(-1 1)']],
          this.tf = d => `translate(${d.nx+d.ny%2} ${d.ny}) ${d.ny%2?'scale(-1 1)':''}`
        },
        rectangular_a: function() {
          Object.assign(this, new wallpapers.p1.rectangular())
          this.edgeTfs = () => [['', `translate(-${this.cpoint[0]} 1) scale(1 -1)`], ['', 'translate(0 -1)']],
          this.tf = d => `translate(${this.cpoint[0]*d.nx} ${d.ny+d.nx%2}) ${d.nx%2?'scale(1 -1)':''}`
        },
        rectangular_b: function() {
          Object.assign(this, new wallpapers.p1.rectangular())
          this.edgeTfs = () => [['', `translate(-${this.cpoint[0]} 0)`], ['', `translate(${this.cpoint[0]} -1) scale(-1 1)`]],
          this.tf = d => `translate(${this.cpoint[0]*(d.nx+d.ny%2)} ${d.ny}) ${d.ny%2?'scale(-1 1)':''}`
        },
      },
      cm: {
        square: function() {
          Object.assign(this, new wallpapers.p1.square())
          this.edgeEnds = [[1,2]]
          this.edgeTfs = () => [['', 'translate(-1 0)', 'scale(-1 1) rotate(-90 0 1)', 'scale(-1 1) rotate(-90 0.5 1.5)']]
          this.tf = d => `translate(${d.nx} ${d.ny})`
        },
        hexagonal_a: function() {
          Object.assign(this, new wallpapers.p1.hexagonal())
          this.edgeEnds = [[1,2]]
          this.edgeTfs = function () {let x=this.cpoint[0];
            return [['', `translate(-${x/2}  0.5)`, `scale(-1 1) translate(-${x} 0)`, `scale(-1 1) translate(-${x*1.5}  0.5)`]]}
          this.tf = d => `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2})`
        },
        hexagonal_b: function() {
          Object.assign(this, new wallpapers.cm.hexagonal_a())
          this.edgeTfs = function () {let x=this.cpoint[0];
            return [['', `translate(-${x/2}  0.5)`, `scale(1 -1) translate(0 -1)`, `scale(1 -1) translate(-${x/2}  -0.5)`]]}
        },
        rhombic_a: function() {
          Object.assign(this, new wallpapers.cm.hexagonal_a())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        },
        rhombic_b: function() {
          Object.assign(this, new wallpapers.cm.hexagonal_b())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      pmm: {},
      pmg: {
        square_a: function() { // vertical mirror
          Object.assign(this, new wallpapers.p2.square())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => [['', 'rotate(180 1 0.5)', 'scale(-1 1) translate(-1 0)', 'scale(-1 1) rotate(180 0.5 0.5)'],
            ['', 'translate(0 -1)', 'scale(-1 1) translate(-1 0)', 'scale(-1 1) translate(-1 -1)']]
          this.tf = d => `translate(${d.nx} ${d.ny}) rotate(${(d.nx)%2 * 180} 0.5 0.5)`
        },
        square_b: function() { // horizontal mirror
          Object.assign(this, new wallpapers.p2.square())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => [['', 'translate(-1 0)', 'scale(1 -1) translate(0 -1)', 'scale(1 -1) translate(-1 -1)'],
            ['', 'rotate(180 0.5 1)', 'scale(1 -1) translate(0 -1)', 'scale(1 -1) rotate(180 0.5 0.5)']]
          this.tf = d => `translate(${d.nx} ${d.ny}) rotate(${(d.ny)%2 * 180} 0.5 0.5)`
        },
        rectangular_a: function() { // vertical mirror
          Object.assign(this, new wallpapers.p2.rectangular())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => {let x = this.cpoint[0];
            return [['', `rotate(180 ${x} 0.5)`, `scale(-1 1) translate(-${x} 0)`, `scale(-1 1) rotate(180 ${x/2} 0.5)`],
                    ['', 'translate(0 -1)', `scale(-1 1) translate(-${x} 0)`, `scale(-1 1) translate(-${x} -1)`]]}
          this.tf = d => `translate(${d.nx*this.cpoint[0]} ${d.ny}) rotate(${(d.nx)%2 * 180} ${this.cpoint[0]/2} 0.5)`
        },
        rectangular_b: function() { // horizontal mirror
          Object.assign(this, new wallpapers.p2.rectangular())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => {let x = this.cpoint[0];
            return [['', `translate(-${x} 0)`, `scale(1 -1) translate(0 -1)`, `scale(1 -1) translate(-${x} -1)`],
                    ['', `rotate(180 ${x/2} 1)`, `scale(1 -1) translate(0 -1)`, `scale(1 -1) rotate(180 ${x/2} 0.5)`]]}
          this.tf = d => `translate(${d.nx*this.cpoint[0]} ${d.ny}) rotate(${(d.ny)%2 * 180} ${this.cpoint[0]/2} 0.5)`
        }
      },
      pgg: {
        square: function() {
          Object.assign(this, new wallpapers.p1.square())
          this.edgeTfs = () => [['', 'translate(-1 1) scale(1 -1)'], ['', 'translate(1 -1) scale(-1 1)']]
          this.tf = d => {let xpar = d.nx%2; let ypar = d.ny%2;
            return `translate(${d.nx+ypar} ${d.ny+xpar}) scale(${1-2*ypar} ${1-2*xpar})`}
        },
        rectangular: function() {
          Object.assign(this, new wallpapers.p1.rectangular())
          this.edgeTfs = () => [['', `translate(-${this.cpoint[0]} 1) scale(1 -1)`], ['', `translate(${this.cpoint[0]} -1) scale(-1 1)`]]
          this.tf = d => {let xpar = d.nx%2; let ypar = d.ny%2;
            return `translate(${(d.nx+ypar)*this.cpoint[0]} ${d.ny+xpar}) scale(${1-2*ypar} ${1-2*xpar})`}
        }
      },
      cmm: {
        square: function () {
          Object.assign(this, new wallpapers.p2.square())
          this.edgeEnds = [[3,4]]
          this.edgeTfs = () => [['', 'rotate(180 0.5 0.5)', 'rotate(180 1 0.5)', 'translate(-1 0)',
            'scale(-1 1) rotate(-90 0.5 1.5)', 'scale(1 -1) rotate(-90)', ' scale(-1 1) rotate(-90 0 1)', 'scale(-1 1) rotate(90 0.5 -0.5)']]
          this.tf = d => `translate(${d.nx} ${d.ny})`
        },
        hexagonal: function() {
          Object.assign(this, new wallpapers.p2.hexagonal())
          this.edgeEnds = [[3,4]]
          this.edgeTfs = () => {let x = this.cpoint[0]
            return [['', `rotate(180 ${x*0.75} 0.25)`, `translate(-${x/2} 0.5)`, `rotate(180 ${x/2} 0.5)`,
            `scale(-1 1) translate(-${x} 0)`, `scale(-1 1) translate(-${x*1.5} 0.5)`, `scale(-1 1) rotate(180 ${x*0.25} 0.25)`, `scale(-1 1) rotate(180 0 0.5)`]]}
          this.tf = d => `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2})`
        },
        rhombic: function() {
          Object.assign(this, new wallpapers.cmm.hexagonal())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      p4: {
        square: function() {
          Object.assign(this, new wallpapers.cmm.square())
          this.edgeTfs = () => [['', 'rotate(90 0.5 0.5)', 'rotate(180 0.5 0.5)', 'rotate(270 0.5 0.5)',
            'rotate(180 1 0.5)', 'rotate(-90 1 1)', 'translate(-1, 0)', 'rotate(90 1 0)']]
        }
      },
      p4m: {},
      p4g: {
        square: function() {
          Object.assign(this, new wallpapers.cmm.square())
          this.edgeTfs = () => [['', 'rotate(180 0.5 0.5)', 'rotate(-90 1 1)', 'rotate(90 1 0)',
            'scale(-1 1) translate(-1 0)', 'scale(-1 1) rotate(90 0.5 -0.5)', 'scale(-1 1) rotate(-90 0.5 1.5)', 'scale(-1 1) rotate(180 0 0.5)']]
          this.tf = d => `translate(${d.nx} ${d.ny}) rotate(${(d.nx+d.ny)%2 * 90} 0.5 0.5)`
        }
      },
      //cpoint not used for hexagons and triangles, 'cause there's no point
      p3: {
        hexagonal_a: function() { // hexagons
          this.anchors = () => [[0, 0.25], [rt3/4, 0], [rt3/2, 0.25], [rt3/2, 0.75], [rt3/4, 1], [0, 0.75]]
          this.edgeEnds = [[2, 3]]
          this.edgeTfs = () => [['', `rotate(120 ${rt3/4} 0.5)`, `rotate(-120 ${rt3/4} 0.5)`,
            `rotate(120 ${rt3/2} 0.25)`, `translate(${-rt3/2} 0)`,`rotate(-120 ${rt3/2} 0.75)`]]
          this.tf = d => `translate(${rt3/2 * (d.nx + (d.ny%2)/2)} ${d.ny*0.75})`
        },
        hexagonal_b: function() { // rhombuses
          Object.assign(this, new wallpapers.p1.hexagonal())
          this.edgeTfs = () => [['', `rotate(120 ${rt3/2} 0)`], ['', `rotate(-120 ${rt3/2} 1)`]]
          this.tf = function (d) { // sorry about the mess..
            const y = d.nx%2 ? d.ny : d.ny%3 == 2 ? d.ny : d.ny + 1 - 2*d.ny%3
            if (y%3) return `translate(${d.nx*rt3/2} ${y - y%3 + (1-y%3%2)*1.5}) rotate(${(2-(d.nx+(y%3))%2)*120} ${rt3/2} 0.5)`
            else return `translate(${(d.nx+0.5)*rt3/2} ${y - (d.nx%2)*1.5 + 0.75})`
          }
        }
      },
      p3m1: {},
      p31m: {
        hexagonal_a: function() { // hexagons
          Object.assign(this, wallpapers.p3.hexagonal_a())
          this.anchors = () => [[    0, 0.25], [rt3/8, 0.125], [rt3/4, 0], [rt3*0.375, 0.125], [rt3/2, 0.25], [rt3/2, 0.5],
                                [rt3/2, 0.75], [rt3/8, 0.875], [rt3/4, 1], [rt3*0.125, 0.875], [    0, 0.75], [    0, 0.5]]
          this.edgeEnds = [[5, 6]]
          const oldEdgeTfs = this.edgeTfs()[0]
          this.edgeTfs = () => [oldEdgeTfs.concat(
            [`scale(-1, 1) rotate(180 ${rt3/4} 0.5)`, `scale(-1, 1) rotate(-60 ${rt3/4} 2)`, `scale(-1, 1) rotate(60 ${rt3/4} -1)`,
            `scale(-1, 1) rotate(180 0 0.5)`, `scale(-1, 1) rotate(-60 0 1.25)`, `scale(-1, 1) rotate(60 0 -0.25)`]
          )]
        },
        hexagonal_b: function() { // rhombuses
          Object.assign(this, new wallpapers.p3.hexagonal_b())
          this.edgeEnds = [[2,3]]
          this.edgeTfs = () => [['', `rotate(-120 ${rt3/2} 1)`, `scale(-1, 1) rotate(60 ${rt3/2} -1)`, 'scale(-1, 1) rotate(180 0 0.5)']]
        }
      },
      p6: {
        hexagonal_a: function() { // hexagons
          Object.assign(this, new wallpapers.p31m.hexagonal_a())
          oldEdgeTfs = this.edgeTfs()[0].slice(0,6)
          this.edgeTfs = () => [oldEdgeTfs.concat([
            `rotate(60 ${rt3/4} 0.5)`, `rotate(180 ${rt3/4} 0.5)`, `rotate(-60 ${rt3/4} 0.5)`,
            `rotate(60 ${rt3/2} -0.25)`, `rotate(180 ${rt3/2} 0.5)`, `rotate(-60 ${rt3/2} 1.25)`,
          ])]
        },
        hexagonal_b: function() { // rhombuses
          Object.assign(this, new wallpapers.p31m.hexagonal_b())
          this.edgeTfs = () => [['', `rotate(-120 ${rt3/2} 1)`, `rotate(180 ${rt3/2} 0.5)`, `rotate(60 ${rt3} 0.5)`]]
        },
        hexagonal_c: function() { // triangles
          this.anchors = () => [[0, 0], [rt3/4, 0.25], [rt3/2, 0.5], [rt3/4, 0.75], [0, 1], [0, 0.5]]
          this.edgeEnds = [[2, 3]]
          this.edgeTfs = () => [['', `rotate(120 ${rt3*third/2} 0.5)`, `rotate(-120 ${rt3*third/2} 0.5)`,
            `rotate(60 ${rt3/2} 0.5)`, `rotate(180 ${rt3/4} 0.75)`, 'rotate(-60 0 1)']]
          this.tf = d => `translate(${d.nx*rt3/2} ${d.ny/2}) rotate(${((d.nx+d.ny)%2+1)*180} ${rt3/4} 0.5)`
        }
      },
      p6m: {}
    }

    const wallpaperDisplays = const wallpapers: [
      [
        {lattice: 'square', hint: '[ ]'},
        {lattice: 'rectangular', hint: '[   ]'},
        {lattice: 'oblique', hint: '\\   \\'},
        {lattice: 'hexagonal', hint: '< >'},
        {lattice: 'rhombic', hint: '<   >'}
      ], [
        {lattice: 'square', hint: '[ ]'},
        {lattice: 'rectangular', hint: '[   ]'},
        {lattice: 'oblique', hint: '\\   \\'},
        {lattice: 'hexagonal', hint: '< >'},
        {lattice: 'rhombic', hint: '<   >'}
      ], [], [
        {lattice: 'square A', hint: '[ ]'},
        {lattice: 'square B', hint: '[ ]'},
        {lattice: 'rectangular A', hint: '[   ]'},
        {lattice: 'rectangular B', hint: '[   ]'}
      ], [
        {lattice: 'square', hint: '[ ]'},
        {lattice: 'hexagonal A', hint: '< >'},
        {lattice: 'hexagonal B', hint: '< >'},
        {lattice: 'rhombic A', hint: '<   >'},
        {lattice: 'rhombic B', hint: '<   >'}
      ], [], [
        {lattice: 'square A', hint: '[ ]'}
        {lattice: 'square B', hint: '[ ]'},
        {lattice: 'rectangular A', hint: '[   ]'},
        {lattice: 'rectangular B', hint: '[   ]'}
      ], [
        {lattice: 'square', hint: '[ ]'},
        {lattice: 'rectangular', hint: '[   ]'}
      ], [
        {lattice: 'square', hint: '[ ]'},
        {lattice: 'hexagonal', hint: '< >'},
        {lattice: 'rhombic', hint: '<   >'}
      ], [
        {lattice: 'square', hint: '[ ]'}
      ], [], [
        {lattice: 'square', hint: '[ ]'}
      ], [
        {lattice: 'hexagonal A', hint: '〔 〕'},
        {lattice: 'hexagonal B', hint: '< >'}
      ], [], [
        {lattice: 'hexagonal A', hint: '〔 〕'},
        {lattice: 'hexagonal B', hint: '< >'}
      ], [
        {lattice: 'hexagonal A', hint: '〔 〕'},
        {lattice: 'hexagonal B', hint: '< >'},
        {lattice: 'hexagonal C', hint: '\\ /'}
      ], []
    ]

    /****************\
    |*              *|
    |*  INITIATION  *|
    |*              *|
    \****************/

    function tile(edges) {
      this.anchors = wallpaper.anchors()
      this.edges = edges || Array.from({length: wallpaper.edgeEnds.length}, () => [])
      this.fullEdges = function() {
        this.anchors = wallpaper.anchors()
        result = []
        for (let i=0; i<wallpaper.edgeEnds.length; i++) {
          result.push([this.anchors[wallpaper.edgeEnds[i][0]]].concat(this.edges[i], [this.anchors[wallpaper.edgeEnds[i][1]]]))
        }
        return result
      }
    }

    const cpointDrag = d3.drag().on('drag', dragCpoint)
    const vertexDrag = d3.drag().on('drag', dragVertex)
    const vertexCreate = d3.drag().on('drag', dragVertex).subject

    var wallpaper = new wallpapers.p3.hexagonal_a()

    init()

    {
      // testing p1.rhombic
      // prototiles[0].edges = [[[rt3/2, 0.5]], [[rt3/2, 0.5]]]
      // prototiles[1].edges = [[[rt3,0]], [[rt3, 1]]]

      // testing pmg.rectangular_a or pmg.rectangular_b
      // wallpaper.cpoint = [1.5,1]
      // prototiles[0].edges = [[[1.85,0.9]],[[1.4,0.75]]]
      // prototiles[1].edges = [[[1.15,0.9]],[[1.4,1.25]]]

      // testing pgg.square
      // prototiles[0].edges = [[[1.25,0.9]],[[0.9,0.75]]]
      // prototiles[1].edges = [[[0.75,0.9]],[[0.9,1.25]]]

      // testing cm.square
      // prototiles[0].edges = [[[1.2,0.4],[1,0.5],[1.4,0.6]]]
      // prototiles[1].edges = [[[0.8,0.4],[1,0.5],[0.6,0.6]]]
      // testing cm.rhombic
      // prototiles[0].edges = [[[rt3*0.7, 0.1],[rt3*0.75, 0.25],[rt3*0.9, 0.05]]]
      // prototiles[1].edges = [[[rt3*0.55, 0.3],[rt3*0.75, 0.25],[rt3*0.75, 0.4]]]

      // testing cmm.square
      // prototiles[0].edges = [[[0.8,0.5]]]
      // prototiles[1].edges = [[[1.2,0.8]]]
      // testing cmm.rhombic
      // prototiles[0].edges = [[[1.5,0.4]]]
      // prototiles[1].edges = [[[1.4,0.5]]]

      // testing p4g.square
      // prototiles[0].edges = [[[0.5,1]]]
      // prototiles[1].edges = [[[1.25,0.75]]]

      // testing p3.hexagonal_a
      prototiles[0].edges = [[[1, 0.25]]]
      prototiles[1].edges = [[[rt3/4, 0.5]]]

      // testing p3.hexagonal_b
      // prototiles[0].edges = [[[rt3*0.75, 0],[rt3, 0.25]],[[rt3*0.5,0.5]]]
      // prototiles[1].edges = [[[rt3*0.5, 0.25],[rt3*0.75, 0.5]],[[rt3,1]]]

      // testing p31m.hexagonal_a or p6.hexagonal_a
      // prototiles[0].edges = [[[1, 0.75]]]
      // prototiles[1].edges = [[[rt3*0.32, 0.55]]]

      // testing p31m.hexagonal_b or p6.hexagonal_b
      // prototiles[0].edges = [[[rt3*0.5,0.5]]]
      // prototiles[1].edges = [[[rt3*0.84,1]]]

      // testing p6.hexagonal_c
      // prototiles[0].edges = [[[rt3/2,1]]]
      // prototiles[1].edges = [[[rt3/4,0.25]]]
    }

    rerenderControls()

    d3.interval(function(t) { if (shouldRedraw) {
      if      (shouldRedraw == 4) restart()
      else if (shouldRedraw == 3) reparameterize()
      else if (shouldRedraw == 2) rerender()
      else                        reupdate()
      shouldRedraw = false
    }});

    /*************\
    |*           *|
    |*  DRAWING  *|
    |*           *|
    \*************/

    // initiate
    function init() {
      svg = d3.select('svg')
        .style('width', width)
        .style('height', height)
      drawing = d3.select('#drawing')
        .attr('transform', `translate(${border} ${border}) scale(${scale})`)
      controls = d3.select('#controls')
        .attr('transform', `translate(${border} ${height - controlHeight - border}) scale(${controlHeight})`)
      reparameterize()
    }

    // enumerate (TODO: add options)
    function reparameterize() {
      parqLocs = d3.cross(d3.range(nw), d3.range(nh), (a, b) => 
      ({
        nx: a,
        ny: b
      }))
      restart()
    }

    // wipe the slate
    function restart() {
      prototiles = [new tile(), new tile()]
      rerenderControls()
    }

    // create
    function rerender() {
      edgeGenerator = edgeGeneratorFactory()
      if (parqElements) parqElements.remove()
      parqElements = drawing.selectAll('g')
        .data(parqLocs).enter().append('g')
        .classed('parq', true)
        .attr('transform', wallpaper.tf.bind(wallpaper))
      edgeTfs = wallpaper.edgeTfs()
      edgeElements = parqElements.selectAll('path')
        .data(loc => edgeData(edgeGenerator((clamp(1, loc.nx, nw-2)-1)/(nw-3)))).enter().append('path')
        .classed('edge', true)
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)
    }

    // mutate
    function reupdate() {
      edgeGenerator = edgeGeneratorFactory()
      if (cmoved) {
        parqElements.attr('transform', wallpaper.tf.bind(wallpaper))
        cmoved = false
      }
      edgeTfs = wallpaper.edgeTfs()
      edgeElements
        .data(loc => edgeData(edgeGenerator((clamp(1, loc.nx, nw-2)-1)/(nw-3))))
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)
    }

    /**************\
    |*            *|
    |*  CONTROLS  *|
    |*            *|
    \**************/

    function rerenderControls() {
      if (prototileElements) prototileElements.remove()
      prototileElements = controls.selectAll('g')
        .data(prototiles).enter().append('g')
        .attr('transform', (d,i,a) => `translate(${i*controlWidth/a.length + 0.25} 0.25) scale(0.5)`)

      if (ptEdgeElements) ptEdgeElements.remove()
      edgeTfs = wallpaper.edgeTfs()
      ptEdgeElements = prototileElements.selectAll('path')
        .data(ptile => edgeData(ptile.fullEdges())).enter().append('path')
        .classed('protoedge', true)
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)
      ptEdgeElements.filter(d => !d.tf)
        .classed('active', true)
        .on('mousedown', addVertex)

      if(ptAnchorElements) ptAnchorElements.remove()
      ptAnchorElements = prototileElements.selectAll('circle.anchor')
        .data(pt => wallpaper.anchors()).enter().append('circle')
        .classed('anchor', true)
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])

      if (ptCpointElements) ptCpointElements.remove()
      if (wallpaper.cpoint) {
        ptCpointElements = prototileElements.selectAll('circle.cpoint')
          .data(pt => [wallpaper.cpoint]).enter().append('circle')
          .classed('cpoint', true)
          .classed('active', wallpaper.cmove.cursor!='default')
          .style('cursor', wallpaper.cmove.cursor)
          .attr('cx', wallpaper.cpoint[0])
          .attr('cy', wallpaper.cpoint[1])
          .call(cpointDrag)
      }

      if(ptVertexWrappers) ptVertexWrappers.remove()
      ptVertexWrappers = prototileElements.selectAll('g')
        .data(pt => pt.edges).enter().append('g')
        .on('contextmenu', deleteVertex)
      ptVertexElements = ptVertexWrappers.selectAll('circle.vertex')
        .data(e => e).enter().append('circle')
        .classed('vertex', true)
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])
        .call(vertexDrag)

      shouldRedraw = Math.max(2, shouldRedraw)
    }

    function reupdateControls() {
      edgeTfs = wallpaper.edgeTfs()
      ptEdgeElements
        .data(ptile => edgeData(ptile.fullEdges()))
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)

      ptAnchorElements
        .data(pt => wallpaper.anchors())
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])

      if (wallpaper.cpoint) {
        ptCpointElements
          .data(pt => [wallpaper.cpoint])
          .attr('cx', wallpaper.cpoint[0])
          .attr('cy', wallpaper.cpoint[1])
      }

      ptVertexElements
        .data(e => e)
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])

      shouldRedraw = Math.max(1, shouldRedraw)
    }

    /***************\
    |*             *|
    |*  LISTENERS  *|
    |*             *|
    \***************/

    function dragVertex(d, i, g) {
      d[0] = d3.event.x
      d[1] = d3.event.y
      reupdateControls()
    }

    function dragCpoint(d, i, g) {
      wallpaper.cpoint.splice(0, 2, ...wallpaper.cmove(d3.event.x, d3.event.y))
      cmoved = true
      reupdateControls()
    }

    function addVertex(d, i, g) {
      const point = clientToLocal(d3.event, this)
      const dist = distanceAlongPath(this, clientToLocal(d3.event, this))
      const whichTile = indexOf(this.parentNode.parentNode.children, this.parentNode)
      const edge = prototiles[whichTile].fullEdges()[i]
      let j = 0
      while (distanceAlongPath(this, edge[j]) < dist && j < edge.length) j++
      for (let k=0; k < prototiles.length; k++) {
        let fulledge = prototiles[k].fullEdges()[i]
        let newVertex = k == whichTile?
          [point.x, point.y]:
          d3.interpolate(fulledge[j-1],fulledge[j])(0.5)
        prototiles[k].edges[i].splice(j-1,0,newVertex)
      }
      rerenderControls()
      let newVertex = ptVertexWrappers._groups[whichTile][i].children[j-1]
      d3.select(newVertex).dispatch('mouseup')
      // selection.dispatch creates a custom event which doesn't have the "view" property
      // d3.drag requires event.view, so we do this "properly" instead
      let mouseDown = new MouseEvent('mousedown',
        {view: window, bubbles: true, cancelable: true}
      );
      newVertex.dispatchEvent(mouseDown)
    }

    function deleteVertex(d, i, g) {
      let e = d3.event
      e.preventDefault()
      const whichTile = indexOf(this.parentNode.parentNode.children, this.parentNode)
      const j = indexOf(e.target.parentNode.children, e.target)
      for (let k=0; k < prototiles.length; k++){
        prototiles[k].edges[i].splice(j, 1)
      }
      rerenderControls()
    }

    /***************\
    |*             *|
    |*  UTILITIES  *|
    |*             *|
    \***************/

    function edgeGeneratorFactory() {
      return d3.piecewise(d3.interpolate, prototiles.map(t => t.fullEdges()))
    }

    function clientToLocal(e, svgEl) {
      let point = svg.node().createSVGPoint()
      point.x = e.clientX; point.y = e.clientY
      point = point.matrixTransform(svgEl.getScreenCTM().inverse())
      return point
    }

    function distanceAlongPath(path, point) {
      const length = path.getTotalLength()
      const delta = length/1024
      let i = 0
      let best, bestDist = length**2

      if (Array.isArray(point)) {
        let temppoint = svg.node().createSVGPoint()
        temppoint.x = point[0]; temppoint.y = point[1]
        point = temppoint
      }

      while (i < 1024 && bestDist > delta**2) {
        let point2 = path.getPointAtLength(i*delta)
        let dist = (point.x-point2.x)**2 + (point.y-point2.y)**2
        if (dist > (64*delta)**2) i+=64
        else if (dist > (8*delta)**2) i+=8
        else i += 1
        if (dist < bestDist) {
          bestDist = dist
          best = i
        }
      }
      return best*delta
    }

    function edgeData(edges) {
      edges = edges.map(edgeHelper)
      let result = []
      for (let i=0; i<wallpaper.edgeEnds.length; i++) {
        for (let j=0; j<edgeTfs[i].length; j++) {
          result.push({
            tf: edgeTfs[i][j],
            data: edges[i]
          })
        }
      }
      return result
    }

    function clamp (a, val, b) {
      return Math.max(a, Math.min(val, b))
    }

    function indexOf(that, e) {
      return Array.prototype.indexOf.call(that, e)
    }

  </script>
</body>
</html>
