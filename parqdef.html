<!doctype html>
<html lang='en'>
<meta charset='utf-8'>
<title>Parquet Definition</title>
<meta content='D3 parquet deformation creator.' name='description'>
<head>
  <style id='miscStyle'>
    * {
      font-family: monospace;
    }
    /* super simple tooltips swiped from what-if.xkcd.com */
    .tooltip {
      display: none;
      position: absolute;
      right: -315px;
      bottom: -1px;
      border: 1px solid black;
      padding: 5px;
      background-color: #eee;
      transform: translateZ(1px);
      white-space:normal;
      word-wrap: break-word;
      width: 300px;
      z-index: 9999;
      overflow: auto;
      cursor: auto;
      user-select: text;
      text-align: left;
    }
    .tooltip :first-child {
      margin-top: 0px;
    }
    .tooltip :last-child {
      margin-bottom: 0px;
    }
    
    #load { position: relative; }
    #load table { width: 100%; }
    #load td:hover {cursor: pointer;}
    #load td:first-child {
      color: #00e;
      text-decoration: underline;
    }
    #load td:last-child {
      position: relative;
      width: 20px;
      height: 20px;
    }
    #load td:last-child::after, #load td:last-child::before {
      width: 16px;
      height: 4px;
      border-radius: 2px;
      top: 9px;
      left: 3px;
      content: '';
      background-color: black;
      position: absolute;
    }
    #load td:last-child::after {transform: rotate(45deg);}
    #load td:last-child::before {transform: rotate(-45deg);}
    #load td.confirm:last-child::after, #load td.confirm:last-child::before {background-color: red}

    #saveArea {
      margin: 10px;
      resize: vertical;
      width: 75%;
    }
  </style><style id='sidebarStyle'>
    #wpWrapper {
      background-color: black;
      padding: 3px;
    }
    #wpDisplay {
      width: 200px;
      border-collapse: collapse;
    }

    .wpGroup:nth-child(2n-1) {background-color: lightgray;}
    .wpGroup:nth-child(2n) {background-color: whitesmoke;}

    tfoot.wpGroup td {
      text-align: center;
      padding: 3px 0;
    }
    
    .wpVariant {display: table-row;}
    .wpVariant:hover {outline: 3px solid rgba(100, 100, 255, 0.75);}
    .wpVariant input {display: none;}

    #wpDisplay td {
      padding-left: 2px; padding-right: 2px;
      border-collapse: collapse;
    }
    .wpSymmetry, .wpLattice {text-align: right;}
    .wpHint {text-align: center;}
    .wpHint code {
      display: block;
      border: 1px solid black;
      padding: 1px;
      padding-top: 0px;
      padding-bottom: 2px;
      background-color: white;
    }
    input:checked ~ * {
      font-weight: bold;
      background-color: #49f;
      color: white;
    }
    input:checked ~ .wpHint code {
      background-color: midnightblue;
      border-color: #49f;
    }
  </style><style id='buttonStyle'>
    .aligntop {vertical-align: top;}

    #buttons {
      display: grid;
      grid-template: 1fr 1fr 1fr 1fr / 42px 42px 42px 42px 30px;
      grid-row-gap: 3px;
    }
    button.span4 {grid-column-end: span 4;}
    button.span2 {grid-column-end: span 2;}
    button.barright {
      border-right-width: 0;
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
    }
    button.barleft {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }
    button.help:not(.general) {
      padding: 2px 6px;
      border-radius: 1000px;
      border: 1px #dadada solid;
      outline: none;
      position: relative;
      place-self: center;
    }
    button.help.general { position: relative; }

    #updateJSON, #loadJSON {position: relative;}
    #updateJSON::before, #loadJSON::before {
      width: 44%;
      right: calc(28% - 2px);
      content: '';
      position: absolute;
      height: 10%;
      border: 2px solid #333;
      bottom: 10%;
    }
    #updateJSON:disabled::after, #updateRendering:disabled::after {border-color: #999}

    /* button styles swiped from google and modified */
    button {
      color: #333333;
      background: #f3f3f3;
      border: 1px #dadada solid;
      padding: 5px;
      border-radius: 4px;
      font-weight: bold;
      font-size: 9pt;
      outline: none;
      cursor: default;
      user-select: none;
    }
    button:hover:not(:disabled) {
      border: 1px #c6c6c6 solid;
      box-shadow: 1px 1px 1px #eaeaea;
      color: #222;
      background: #f7f7f7;
    }
    button:active {box-shadow: inset 1px 1px 1px #dfdfdf;}
    button:disabled {
      color: #999;
      background-color: #fff;
    }
    button.label {
      color: #333333;
      border: none;
    }
    button.error, button.error:hover:not(:disabled) {
      background-color: #faa;
    }
  </style><style id='controlStyle'>
    path.protoedge {
      stroke: #444;
      stroke-width: 0.04;
      fill: none;
    }
    path.protoedge.active {
      stroke: blue;
      cursor: copy;
    }

    circle.anchor {
      fill: black;
      r: 0.06px;
    }
    circle.cpoint {
      stroke-width: 0.025;
      stroke: black;
      fill: gray;
      r: 0.07px;
    }
    circle.cpoint.active {
      stroke: #c00;
      fill: #f90;
    }
    circle.vertex {
      stroke-width: 0.025;
      stroke: #00a;
      fill: #88f;
      cursor: move;
      r: 0.07px;
      opacity: 0.9
    }
  </style><style id='parqStyle' type='text/css'>
    path.edge {
      stroke: black;
      stroke-width: 0.05;
      fill: none;
    }
  </style>
</head>
<body>
  <table>
    <tr>
      <td><nobr><div id='wpWrapper'>
        <table id='wpDisplay'>
          <tfoot class='wpGroup'>
            <td><button class='help wallpapers'>?</button></td>
            <td><button class='help lattices'>?</button></td>
            <td><button class='help mnemonics'>?</button></td>
          </tfoot>
        </table>
      </div></nobr></td>
      <td><svg id='main'>
        <g id='drawing'></g>
        <g id='controls'></g>
      </svg></td>
    </tr>
    <tr>
      <td class='aligntop'><div id='buttons'>
          <button id='downloadSVG' class='span4'>Download SVG</button>
          <button class='help download'>?</button>
          <button id='labelJSON' class='label' disabled>JSON</button>
          <button id='loadJSON' class='barright'>â¬†</button>
          <button id='updateJSON' class='barright barleft'>â¬‡</button>
          <button id='lockJSON' class='barleft'>ðŸ”“</button>
          <button class='help JSON'>?</button>
          <button id='labelRendering' class = 'label span2' disabled>Rendering</button>
          <button id='updateRendering' disabled class='barright'>â¬†</button>
          <button id='lockRendering' class='barleft'>ðŸ”“</button>
          <button class='help rendering'>?</button>
          <button id='save' class='span2 barright'>Save</button>
          <button id='load' class='span2 barleft'>Load...<div id='saveList' class='tooltip'></div></button>
          <button class='help storage'>?</button>
          <button class='help general span4'>Help</button>
      </div></td>
      <td>
        <textarea id='saveArea' rows=10></textarea>
      </td>
    </tr>
  </table>
  
  <script src='https://d3js.org/d3.v4.js'></script>
  <script src="https://d3js.org/d3-drag.v1.min.js"></script>
  <script src='https://d3js.org/d3-array.v1.min.js'></script>
  <script src='https://d3js.org/d3-shape.v1.js'></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
  <script src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/14082/FileSaver.js"></script>

  <script>

    //  â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆ     â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ   â–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ 
    // â–ˆ     â–ˆ     â–ˆ   â–ˆ â–ˆ     â–ˆ     â–ˆ   â–ˆ â–ˆ     â–ˆ   â–ˆ   â–ˆ   â–ˆâ–ˆ  â–ˆ â–ˆ     
    //  â–ˆâ–ˆâ–ˆ  â–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ   â–ˆ   â–ˆ â–ˆ     â–ˆ   â–ˆ   â–ˆ   â–ˆ â–ˆ â–ˆ â–ˆ  â–ˆâ–ˆ 
    //     â–ˆ â–ˆ     â–ˆ   â–ˆ â–ˆ     â–ˆ     â–ˆ   â–ˆ â–ˆ     â–ˆ   â–ˆ   â–ˆ   â–ˆ  â–ˆâ–ˆ â–ˆ   â–ˆ 
    // â–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆ â–ˆ   â–ˆ â–ˆ     â–ˆ      â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ   â–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ 

    // d3 selections of relevent elements
    var svg, drawing, controls, wpDisplay, symmetryElements, latticeElements, 
      helpElements, saveArea, saveElements, eraseElements // defined by init
    var parqLocs, parqElements, edgeElements // defined by rerender
    var prototileElements, ptEdgeElements, ptCpointElements, ptAnchorElements,
      ptVertexWrappers, ptVertexElements // defined by rerenderControls

    // variables of current deformation
    var wallpaper         // which symmetry is in use
    var prototiles        // the endpoints (and middlepoints) of the deformation; defined by restart
    var edgeGenerator     // interpolates between prototiles; defined by rerender and reupdate
    var edgeTfs           // calculated from wallpaper.edgeTfs(); defined whenever it needs to be
    var nw = 23, nh = 11  // width and height of drawing in number of tiles
    var name = 'parquet'  // save name

    // UI constants for large sections
    const border = 30, width = 1200, controlHeight = 150, controlWidth = width/controlHeight
    const scale = (width - border*2)/(1.5*nw), height = scale*nh + controlHeight + border*3

    // UI state flags
    var shouldRedraw = false  // this > 0 means redraw next frame
    var cmoved = false        // was the cpoint was moved last frame
    var liveSave = true       // should the JSON be live-updated
    var liveDrawing = true    // should the drawing be live-updated
    var saveConfirm = false   // waiting for confirmation on overwriting save
    var deleteConfirm = false // waiting for confirmation on deleting save
    
    // Utilities that aren't simple function definitions
    const edgeHelper = d3.line() // creates svg path data strings from lists of points
      .defined(d => d!==false)   // for future addition of line of 
    const assign = Object.assign // this is super useful

    const tips = {
      general: `<p>This is Parquet Definitions, a tool for making neat geometric Escherian art.</p>${''
        }<ul>${''
        }  <li>Click and on blue lines to create vertices (blue points)</li>${''
        }  <li>Drag vertices to change the shape of the tiles</li>${''
        }  <li>Right click vertices to delete them</li>${''
        }  <li>Click on left sidebar to choose a different symmetry; this will reset all vertices</li>${''
        }  <li>Many symmetries have an additional orange point which controls the dimensions of the tiles</li>${''
        }  <li>Control-Z works, although it only operates on the text representation of the tiling</li>${''
        }</ul>`,
      wallpapers: 'These are the <a href="https://en.wikipedia.org/wiki/Wallpaper_group">wallpaper groups</a>. They determine the symmetry of the resulting tesselation. There are 17 in total; not all of them are present due to technical limitations with the implementation, but there\'s still plenty of variety. Experiment!',
      lattices: 'These are the lattices of the tesselation, or how the centers of the tiles are arranged. Some wallpaper groups allow for multiple lattices, and some do not. Since the orientation of the symmetry matters for parquet deformations, many of the group/lattice pairs are included multiple times.',
      mnemonics: 'These are mnemonics which attempt to give an idea of what using the specific variant will look like.',
      download: 'SVG is an image format which can be displayed by any modern browser. It\'s a vector format, which means it stores shapes and positions instead of pixels. If you want a png instead, take a screenshot using the Snipping Tool on Windows and Shift-Command-4 on Mac.',
      JSON: '<p>JSON is a data storage format which is used to store your deformation. If you\'re not familiar, it\'s pretty simple: numbers go in verbatim, text goes in "quotes", lists go in ["square", "brackets"], and objects with named properties go in {"curly":"brackets"}.</p><p>You can modify the JSON and then load from it with the "â¬†" button for precision modification. If you want to mess with the prototiles without disturbing your JSON, you can lock it, and click the "â¬‡" button if you want to update it.</p>',
      rendering: 'If your computer struggles to keep up whenever you change the prototiles, then it may be a good idea to lock the rendering, and click the "â¬†" button when you adjust them.',
      storage: 'These buttons save and load parquet deformations locally in your browser. Use the "name" field of the JSON in order to save different patterns.'
    }

    const rt3 = Math.sqrt(3)
    const third = 1/3

    // note: inconsistent use of arrow functions and `function()` functions, because I prefer arrow functions in
    // crowded definitions like this, but sometimes they can't be used because their `this` can't be rebound
    const wallpapers = {
      p1: {
        square: function() {
          this.cpoint = [1, 1] // control point. in the future may be variable between tiles
          this.cmove = (x,y) => [1, 1]; this.cmove.cursor = 'default' // how the cpoint changes if it is dragged to x,y
          this.anchors = function () {return [[0, 0], [1, 0], this.cpoint, [0, 1]]} // corners
          this.edgeEnds = [
            [1, 2], // values are indices of this.anchors
            [2, 3]  // if variable cpoints implemented, will instead be indices of tile.anchors
          ]
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', 'translate(0 -1)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny})`}
        },
        rectangular: function() {
          assign(this, new wallpapers.p1.square())
          this.cmove = (x,y) => [x,1]; this.cmove.cursor = 'ew-resize'
          this.anchors = function () {return [[0, 0], [this.cpoint[0], 0], this.cpoint, [0, 1]]}
          this.edgeTfs = () => [['', `translate(${-this.cpoint[0]} 0)`], ['', 'translate(0 -1)']]
          this.tf = function(d) {return `translate(${this.cpoint[0]*d.nx} ${d.ny})`}
        },
        oblique: function() {
          assign(this, new wallpapers.p1.square())
          this.cmove = (x,y) => [x,y]; this.cmove.cursor = 'move'
          this.anchors = () => [[0, 0], [1, 0], this.cpoint, [this.cpoint[0]-1, this.cpoint[1]]]
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', `translate(${1-this.cpoint[0]} ${-this.cpoint[1]})`]]
          this.tf = function(d) {return `translate(${d.nx + (this.cpoint[0]%1)*d.ny} ${this.cpoint[1] * d.ny})`}
        },
        hexagonal: function() {
          this.cpoint = [Math.sqrt(3), 0.5]
          this.cmove = (x,y) => [this.cpoint[0],0.5]; this.cmove.cursor = 'default'
          this.anchors = function () {return [[0, 0.5], [this.cpoint[0]/2, 0], this.cpoint, [this.cpoint[0]/2, 1]]}
          this.edgeEnds = [[1, 2], [2, 3]],
          this.edgeTfs = () => [['',`translate(${-this.cpoint[0]/2} 0.5)`],['',`translate(${-this.cpoint[0]/2} -0.5)`]]
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2})`}
        },
        rhombic: function() {
          assign(this, new wallpapers.p1.hexagonal())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      p2: {
        square: function() {
          this.cpoint = [1,1]
          this.cmove = (x,y) => [1,1]; this.cmove.cursor = 'default'
          this.anchors = () => [[0, 0], [0.5, 0], [1, 0], [1, 0.5], [1, 1], [0.5, 1], [0, 1], [0, 0.5]]
          this.edgeEnds = [[0,1],[2,3],[4,5],[6,7]]
          this.edgeTfs = function () {let a = this.anchors(); return Array.from({length:4}, (e,i) => ['', `rotate(180 ${a[i*2+1]})`])}
          this.tf = function(d) {return `translate(${d.nx} ${d.ny}) rotate(${(d.nx+d.ny)%2 * 180} 0.5 0.5)`}
        },
        rectangular: function() {
          assign(this, new wallpapers.p2.square())
          this.cmove = (x,y) => [x,1]; this.cmove.cursor = 'ew-resize'
          this.anchors = function () {let x=this.cpoint[0]; return [[0, 0], [x/2, 0], [x, 0], [x, 0.5], [x, 1], [x/2, 1], [0, 1], [0, 0.5]]}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]} ${d.ny}) rotate(${(d.nx+d.ny)%2 * 180} ${this.cpoint[0]/2} 0.5)`}
        },
        oblique: function() {
          assign(this, new wallpapers.p2.square())
          this.cmove = (x,y) => [x,y]; this.cmove.cursor = 'move'
          this.anchors = () => {let x=this.cpoint[0]; let y=this.cpoint[1];
            return [[0, 0], [0.5, 0], [1, 0], [x/2+0.5, y/2], [x, y], [x-0.5, y], [x-1, y], [(x-1)/2, y/2]]}
          this.tf = function(d) {let x=this.cpoint[0]; let y=this.cpoint[1];
            return `translate(${d.nx + (x%1)*d.ny} ${y*d.ny}) rotate(${(d.nx+d.ny)%2 * 180} ${x/2} ${y/2})`}
        },
        hexagonal: function() {
          this.cpoint = [Math.sqrt(3), 0.5]
          this.cmove = (x,y) => [this.cpoint[0],0.5]; this.cmove.cursor = 'default'
          this.anchors = function() {let x=this.cpoint[0];
            return [[0, 0.5], [x*0.25, 0.25], [x*0.5, 0], [x*0.75, 0.25], [x, 0.5], [x*0.75, 0.75], [x*0.5, 1], [x*0.25, 0.75]]}
          this.edgeEnds = [[0,1],[2,3],[4,5],[6,7]]
          this.edgeTfs = function() {a = this.anchors(); return Array.from({length:4}, (e,i) => ['', `rotate(180 ${a[i*2+1]})`])}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2}) rotate(${d.nx%2 * 180} ${this.cpoint[0]/2} 0.5)`}
        },
        rhombic: function() {
          assign(this, new wallpapers.p2.hexagonal())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      pm: {},
      pg: {
        square_a: function() {
          assign(this, new wallpapers.p1.square())
          this.edgeTfs = () => [['', 'translate(-1 1) scale(1 -1)'], ['', 'translate(0 -1)']],
          this.tf = function(d) {return `translate(${d.nx} ${d.ny+d.nx%2}) ${d.nx%2?'scale(1 -1)':''}`}
        },
        square_b: function() {
          assign(this, new wallpapers.p1.square())
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', 'translate(1 -1) scale(-1 1)']],
          this.tf = function(d) {return `translate(${d.nx+d.ny%2} ${d.ny}) ${d.ny%2?'scale(-1 1)':''}`}
        },
        rectangular_a: function() {
          assign(this, new wallpapers.p1.rectangular())
          this.edgeTfs = () => [['', `translate(${-this.cpoint[0]} 1) scale(1 -1)`], ['', 'translate(0 -1)']],
          this.tf = function(d) {return `translate(${this.cpoint[0]*d.nx} ${d.ny+d.nx%2}) ${d.nx%2?'scale(1 -1)':''}`}
        },
        rectangular_b: function() {
          assign(this, new wallpapers.p1.rectangular())
          this.edgeTfs = () => [['', `translate(${-this.cpoint[0]} 0)`], ['', `translate(${this.cpoint[0]} -1) scale(-1 1)`]],
          this.tf = function(d) {return `translate(${this.cpoint[0]*(d.nx+d.ny%2)} ${d.ny}) ${d.ny%2?'scale(-1 1)':''}`}
        },
      },
      cm: {
        square: function() {
          assign(this, new wallpapers.p1.square())
          this.edgeEnds = [[1,2]]
          this.edgeTfs = () => [['', 'translate(-1 0)', 'scale(-1 1) rotate(-90 0 1)', 'scale(-1 1) rotate(-90 0.5 1.5)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny})`}
        },
        hexagonal_a: function() {
          assign(this, new wallpapers.p1.hexagonal())
          this.edgeEnds = [[1,2]]
          this.edgeTfs = function () {let x=this.cpoint[0];
            return [['', `translate(${-x/2}  0.5)`, `scale(-1 1) translate(${-x} 0)`, `scale(-1 1) translate(${-x*1.5}  0.5)`]]}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2})`}
        },
        hexagonal_b: function() {
          assign(this, new wallpapers.cm.hexagonal_a())
          this.edgeTfs = function () {let x=this.cpoint[0];
            return [['', `translate(${-x/2}  0.5)`, `scale(1 -1) translate(0 -1)`, `scale(1 -1) translate(${-x/2}  -0.5)`]]}
        },
        rhombic_a: function() {
          assign(this, new wallpapers.cm.hexagonal_a())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        },
        rhombic_b: function() {
          assign(this, new wallpapers.cm.hexagonal_b())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      pmm: {},
      pmg: {
        square_a: function() { // vertical mirror
          assign(this, new wallpapers.p2.square())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => [['', 'rotate(180 1 0.5)', 'scale(-1 1) translate(-1 0)', 'scale(-1 1) rotate(180 0.5 0.5)'],
            ['', 'translate(0 -1)', 'scale(-1 1) translate(-1 0)', 'scale(-1 1) translate(-1 -1)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny}) rotate(${(d.nx)%2 * 180} 0.5 0.5)`}
        },
        square_b: function() { // horizontal mirror
          assign(this, new wallpapers.p2.square())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => [['', 'translate(-1 0)', 'scale(1 -1) translate(0 -1)', 'scale(1 -1) translate(-1 -1)'],
            ['', 'rotate(180 0.5 1)', 'scale(1 -1) translate(0 -1)', 'scale(1 -1) rotate(180 0.5 0.5)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny}) rotate(${(d.ny)%2 * 180} 0.5 0.5)`}
        },
        rectangular_a: function() { // vertical mirror
          assign(this, new wallpapers.p2.rectangular())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => {let x = this.cpoint[0];
            return [['', `rotate(180 ${x} 0.5)`, `scale(-1 1) translate(${-x} 0)`, `scale(-1 1) rotate(180 ${x/2} 0.5)`],
                    ['', 'translate(0 -1)', `scale(-1 1) translate(${-x} 0)`, `scale(-1 1) translate(${-x} -1)`]]}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]} ${d.ny}) rotate(${(d.nx)%2 * 180} ${this.cpoint[0]/2} 0.5)`}
        },
        rectangular_b: function() { // horizontal mirror
          assign(this, new wallpapers.p2.rectangular())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => {let x = this.cpoint[0];
            return [['', `translate(${-x} 0)`, `scale(1 -1) translate(0 -1)`, `scale(1 -1) translate(${-x} -1)`],
                    ['', `rotate(180 ${x/2} 1)`, `scale(1 -1) translate(0 -1)`, `scale(1 -1) rotate(180 ${x/2} 0.5)`]]}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]} ${d.ny}) rotate(${(d.ny)%2 * 180} ${this.cpoint[0]/2} 0.5)`}
        }
      },
      pgg: {
        square: function() {
          assign(this, new wallpapers.p1.square())
          this.edgeTfs = () => [['', 'translate(-1 1) scale(1 -1)'], ['', 'translate(1 -1) scale(-1 1)']]
          this.tf = function(d) {let xpar = d.nx%2; let ypar = d.ny%2;
            return `translate(${d.nx+ypar} ${d.ny+xpar}) scale(${1-2*ypar} ${1-2*xpar})`}
        },
        rectangular: function() {
          assign(this, new wallpapers.p1.rectangular())
          this.edgeTfs = () => [['', `translate(${-this.cpoint[0]} 1) scale(1 -1)`], ['', `translate(${this.cpoint[0]} -1) scale(-1 1)`]]
          this.tf = function(d) {let xpar = d.nx%2; let ypar = d.ny%2;
            return `translate(${(d.nx+ypar)*this.cpoint[0]} ${d.ny+xpar}) scale(${1-2*ypar} ${1-2*xpar})`}
        }
      },
      cmm: {
        square: function () {
          assign(this, new wallpapers.p2.square())
          this.edgeEnds = [[3,4]]
          this.edgeTfs = () => [['', 'rotate(180 0.5 0.5)', 'rotate(180 1 0.5)', 'translate(-1 0)',
            'scale(-1 1) rotate(-90 0.5 1.5)', 'scale(1 -1) rotate(-90)', ' scale(-1 1) rotate(-90 0 1)', 'scale(-1 1) rotate(90 0.5 -0.5)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny})`}
        },
        hexagonal: function() {
          assign(this, new wallpapers.p2.hexagonal())
          this.edgeEnds = [[3,4]]
          this.edgeTfs = () => {let x = this.cpoint[0]
            return [['', `rotate(180 ${x*0.75} 0.25)`, `translate(${-x/2} 0.5)`, `rotate(180 ${x/2} 0.5)`,
            `scale(-1 1) translate(${-x} 0)`, `scale(-1 1) translate(${-x*1.5} 0.5)`, `scale(-1 1) rotate(180 ${x*0.25} 0.25)`, `scale(-1 1) rotate(180 0 0.5)`]]}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2})`}
        },
        rhombic: function() {
          assign(this, new wallpapers.cmm.hexagonal())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      p4: {
        square: function() {
          assign(this, new wallpapers.cmm.square())
          this.edgeTfs = () => [['', 'rotate(90 0.5 0.5)', 'rotate(180 0.5 0.5)', 'rotate(270 0.5 0.5)',
            'rotate(180 1 0.5)', 'rotate(-90 1 1)', 'translate(-1, 0)', 'rotate(90 1 0)']]
        }
      },
      p4m: {},
      p4g: {
        square: function() {
          assign(this, new wallpapers.cmm.square())
          this.edgeTfs = () => [['', 'rotate(180 0.5 0.5)', 'rotate(-90 1 1)', 'rotate(90 1 0)',
            'scale(-1 1) translate(-1 0)', 'scale(-1 1) rotate(90 0.5 -0.5)', 'scale(-1 1) rotate(-90 0.5 1.5)', 'scale(-1 1) rotate(180 0 0.5)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny}) rotate(${(d.nx+d.ny)%2 * 90} 0.5 0.5)`}
        }
      },
      //cpoint not used for hexagons and triangles, 'cause there's no point
      p3: {
        hexagonal_a: function() { // hexagons
          this.anchors = () => [[0, 0.25], [rt3/4, 0], [rt3/2, 0.25], [rt3/2, 0.75], [rt3/4, 1], [0, 0.75]]
          this.edgeEnds = [[2, 3]]
          this.edgeTfs = () => [['', `rotate(120 ${rt3/4} 0.5)`, `rotate(-120 ${rt3/4} 0.5)`,
            `rotate(120 ${rt3/2} 0.25)`, `translate(${-rt3/2} 0)`,`rotate(-120 ${rt3/2} 0.75)`]]
          this.tf = function(d) {return `translate(${rt3/2 * (d.nx + (d.ny%2)/2)} ${d.ny*0.75})`}
        },
        hexagonal_b: function() { // rhombuses
          assign(this, new wallpapers.p1.hexagonal())
          this.edgeTfs = () => [['', `rotate(120 ${rt3/2} 0)`], ['', `rotate(-120 ${rt3/2} 1)`]]
          this.tf = function (d) { // sorry about the mess..
            const y = d.nx%2 ? d.ny : d.ny%3 == 2 ? d.ny : d.ny + 1 - 2*d.ny%3
            if (y%3) return `translate(${d.nx*rt3/2} ${y - y%3 + (1-y%3%2)*1.5}) rotate(${(2-(d.nx+(y%3))%2)*120} ${rt3/2} 0.5)`
            else return `translate(${(d.nx+0.5)*rt3/2} ${y - (d.nx%2)*1.5 + 0.75})`
          }
        }
      },
      p3m1: {},
      p31m: {
        hexagonal_a: function() { // hexagons
          assign(this, new wallpapers.p3.hexagonal_a())
          this.anchors = () => [[    0, 0.25], [rt3/8, 0.125], [rt3/4, 0], [rt3*0.375, 0.125], [rt3/2, 0.25], [rt3/2, 0.5],
                                [rt3/2, 0.75], [rt3*0.375, 0.875], [rt3/4, 1], [rt3*0.125, 0.875], [    0, 0.75], [    0, 0.5]]
          this.edgeEnds = [[5, 6]]
          const oldEdgeTfs = this.edgeTfs()[0]
          this.edgeTfs = () => [oldEdgeTfs.concat(
            [`scale(-1, 1) rotate(180 ${rt3/4} 0.5)`, `scale(-1, 1) rotate(-60 ${rt3/4} 2)`, `scale(-1, 1) rotate(60 ${rt3/4} -1)`,
            `scale(-1, 1) rotate(180 0 0.5)`, `scale(-1, 1) rotate(-60 0 1.25)`, `scale(-1, 1) rotate(60 0 -0.25)`]
          )]
        },
        hexagonal_b: function() { // rhombuses
          assign(this, new wallpapers.p3.hexagonal_b())
          this.edgeEnds = [[2,3]]
          this.edgeTfs = () => [['', `rotate(-120 ${rt3/2} 1)`, `scale(-1, 1) rotate(60 ${rt3/2} -1)`, 'scale(-1, 1) rotate(180 0 0.5)']]
        }
      },
      p6: {
        hexagonal_a: function() { // hexagons
          assign(this, new wallpapers.p31m.hexagonal_a())
          oldEdgeTfs = this.edgeTfs()[0].slice(0,6)
          this.edgeTfs = () => [oldEdgeTfs.concat([
            `rotate(60 ${rt3/4} 0.5)`, `rotate(180 ${rt3/4} 0.5)`, `rotate(-60 ${rt3/4} 0.5)`,
            `rotate(60 ${rt3/2} -0.25)`, `rotate(180 ${rt3/2} 0.5)`, `rotate(-60 ${rt3/2} 1.25)`,
          ])]
        },
        hexagonal_b: function() { // rhombuses
          assign(this, new wallpapers.p31m.hexagonal_b())
          this.edgeTfs = () => [['', `rotate(-120 ${rt3/2} 1)`, `rotate(180 ${rt3/2} 0.5)`, `rotate(60 ${rt3} 0.5)`]]
        },
        hexagonal_c: function() { // triangles
          this.anchors = () => [[0, 0], [rt3/4, 0.25], [rt3/2, 0.5], [rt3/4, 0.75], [0, 1], [0, 0.5]]
          this.edgeEnds = [[2, 3]]
          this.edgeTfs = () => [['', `rotate(120 ${rt3*third/2} 0.5)`, `rotate(-120 ${rt3*third/2} 0.5)`,
            `rotate(60 ${rt3/2} 0.5)`, `rotate(180 ${rt3/4} 0.75)`, 'rotate(-60 0 1)']]
          this.tf = function(d) {return `translate(${d.nx*rt3/2} ${d.ny/2}) rotate(${((d.nx+d.ny)%2+1)*180} ${rt3/4} 0.5)`}
        }
      },
      p6m: {}
    }

    // for display
    const wpData = [
      [
        {constructor: wallpapers.p1.rectangular, symmetry: 'p1', lattice: 'Rectangular', hint: '[ o ]'},
        {constructor: wallpapers.p1.oblique, symmetry: 'p1', lattice: 'Oblique', hint: '\\ o \\'},
        {constructor: wallpapers.p1.rhombic, symmetry: 'p1', lattice: 'Rhombic', hint: '< o >'}
      ], [
        {constructor: wallpapers.p2.rectangular, symmetry: 'p2', lattice: 'Rectangular', hint: '[ ~ ]'},
        {constructor: wallpapers.p2.oblique, symmetry: 'p2', lattice: 'Oblique', hint: '\\ ~ \\'},
        {constructor: wallpapers.p2.rhombic, symmetry: 'p2', lattice: 'Rhombic', hint: '< ~ >'}
      ], [
        {constructor: wallpapers.pg.rectangular_a, symmetry: 'pg', lattice: 'Rectangular A', hint: '[ Z ]'},
        {constructor: wallpapers.pg.rectangular_b, symmetry: 'pg', lattice: 'Rectangular B', hint: '[ N ]'}
      ], [
        {constructor: wallpapers.cm.square, symmetry: 'cm', lattice: 'Square', hint: ' [/] '},
        {constructor: wallpapers.cm.rhombic_a, symmetry: 'cm', lattice: 'Rhombic A', hint: '< T >'},
        {constructor: wallpapers.cm.rhombic_b, symmetry: 'cm', lattice: 'Rhombic B', hint: '< E >'}
      ], [
        {constructor: wallpapers.pmg.rectangular_a, symmetry: 'pmg', lattice: 'Rectangular A', hint: '[ T ]'},
        {constructor: wallpapers.pmg.rectangular_b, symmetry: 'pmg', lattice: 'Rectangular B', hint: '[ E ]'}
      ], [
        {constructor: wallpapers.pgg.rectangular, symmetry: 'pgg', lattice: 'Rectangular', hint: '[ % ]'}
      ], [
        {constructor: wallpapers.cmm.square, symmetry: 'cmm', lattice: 'Square', hint: ' [X] '},
        {constructor: wallpapers.cmm.rhombic, symmetry: 'cmm', lattice: 'Rhombic', hint: '< X >'}
      ], [
        {constructor: wallpapers.p4.square, symmetry: 'p4', lattice: 'Square', hint: ' [+] '}
      ], [
        {constructor: wallpapers.p4g.square, symmetry: 'p4g', lattice: 'Square', hint: ' [H] '}
      ], [
        {constructor: wallpapers.p3.hexagonal_a, symmetry: 'p3', lattice: 'Hexagonal A', hint: 'ã€” ã€•'},
        {constructor: wallpapers.p3.hexagonal_b, symmetry: 'p3', lattice: 'Hexagonal B', hint: ' < > '}
      ], [
        {constructor: wallpapers.p31m.hexagonal_a, symmetry: 'p31m', lattice: 'Hexagonal A', hint: 'ã€”Yã€•'},
        {constructor: wallpapers.p31m.hexagonal_b, symmetry: 'p31m', lattice: 'Hexagonal B', hint: ' <Y> '}
      ], [
        {constructor: wallpapers.p6.hexagonal_a, symmetry: 'p6', lattice: 'Hexagonal A', hint: 'ã€”*ã€•'},
        {constructor: wallpapers.p6.hexagonal_b, symmetry: 'p6', lattice: 'Hexagonal B', hint: ' <*> '},
        {constructor: wallpapers.p6.hexagonal_c, symmetry: 'p6', lattice: 'Hexagonal C', hint: ' |*> '}
      ]
    ]

    // simple tile class
    function tile(edges) {
      this.anchors = wallpaper.anchors()
      this.edges = edges || Array.from({length: wallpaper.edgeEnds.length}, () => [])
      this.fullEdges = function() {
        this.anchors = wallpaper.anchors()
        result = []
        for (let i=0; i<wallpaper.edgeEnds.length; i++) {
          result.push([this.anchors[wallpaper.edgeEnds[i][0]]].concat(this.edges[i], [this.anchors[wallpaper.edgeEnds[i][1]]]))
        }
        return result
      }
    }

    const examples = {
      "example: triangulation": JSON.stringify(
        {"name":"example: triangulation","symmetry":"p6","lattice":"hexagonal_c","tiles":[
          [[[0.8119,0.5313],[0.7036,0.5938],[0.6495,0.625],[0.5954,0.6563],[0.4872,0.7188]]],
          [[[0.866,0.625],[0.866,0.875],[0.866,1],[0.7577,0.9375],[0.5413,0.8125]]],
          [[[1.1,0.625],[0.6495,0.875],[0.866,1],[0.6495,1.125],[0.6495,0.625]]]]}),
      "example: fish scales": JSON.stringify(
        {"name":"example: fish scales","symmetry":"cm","lattice":"rhombic_b","cpoint":[2,0.5],"tiles":[
          [[[1.5,0],[1.8866,0.2175]]],
          [[[0.33,0.4],[1.33,0.1]]]]}),
      "example: rotary saw": JSON.stringify(
        {"name":"example: rotary saw","symmetry":"p6","lattice":"hexagonal_a","tiles":[
          [[[1.299,0.5],[1.1547,0.75]]],
          [[[0.866,0.5],[0.866,0.75]]],
          [[[0.433,0.5],[0.5773,0.747]]]]}),
      "example: jungle leaves": JSON.stringify({
        "name": "example: jungle leaves", "symmetry": "p3", "lattice": "hexagonal_a",
        "tiles": [
          [[[1.299,0.5],[1.299,1],[0.866,0.25]]],
          [[[0.866,0.25],[1.299,0.50],[0.866,0.75]]]]}),
    }

    const cpointDrag = d3.drag().on('start', updateJSON).on('drag', dragCpoint)
    const vertexDrag = d3.drag().on('start', updateJSON).on('drag', dragVertex)

    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ   â–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆ   â–ˆ           
    //   â–ˆ   â–ˆâ–ˆ  â–ˆ   â–ˆ     â–ˆ     â–ˆ   â–ˆ   â–ˆ   â–ˆ     â–ˆ   â–ˆ   â–ˆ â–ˆâ–ˆ  â–ˆ           
    //   â–ˆ   â–ˆ â–ˆ â–ˆ   â–ˆ     â–ˆ     â–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆ     â–ˆ   â–ˆ   â–ˆ â–ˆ â–ˆ â–ˆ           
    //   â–ˆ   â–ˆ  â–ˆâ–ˆ   â–ˆ     â–ˆ     â–ˆ   â–ˆ   â–ˆ   â–ˆ     â–ˆ   â–ˆ   â–ˆ â–ˆ  â–ˆâ–ˆ           
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ   â–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ   â–ˆ   â–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆ   â–ˆ

    init()

    // this is the "most powerful" method; calling it will update everything that isn't "locked"
    rerenderControls()

    // updating so many SVG elements is expensive, so it goes in a d3 timer instead of a listener
    d3.interval(function(t) { if (shouldRedraw) {
      if      (shouldRedraw == 3) restart()
      else if (shouldRedraw == 2) rerender()
      else                        reupdate()
      shouldRedraw = false
    }})

    // three guesses what this does
    function init() {
      initSidebar()
      initButtons()
      initSVG()
    }

    // symmetry sidebar
    function initSidebar() {
      wpDisplay = d3.select('#wpDisplay').datum(wpData)
      symmetryElements = wpDisplay.selectAll('tbody')
        .data(d => d).enter().insert('tbody',':last-child')
        .classed('wpGroup', true)
      latticeElements = symmetryElements.selectAll('label')
        .data(d => d).enter().append('label')
        .classed('wpVariant', true)
        .attr('for', d => d.symmetry+d.lattice.replace(/ /g, ''))
        .on('click', d => {wallpaper = new d.constructor(); restart()})
      latticeElements
        .append('input')
        .attr('type', 'radio')
        .attr('name', 'wallpaper')
        .attr('id', d => d.symmetry+d.lattice.replace(/ /g, ''))
      latticeElements
        .append('td')
        .classed('wpSymmetry', true)
        .append('label')
        .text(d => d.symmetry)
      latticeElements
        .append('td')
        .classed('wpLattice', true)
        .text(d => d.lattice)
      latticeElements
        .append('td')
        .classed('wpHint', true)
        .append('code')
        .text(d => d.hint)
    }

    // other non-svg controls
    function initButtons() {
      saves = localStorage.getItem('deformations')
      if (saves === null || saves[0] === '[' || saves[1] === '}') saves = examples
      else saves = JSON.parse(saves)

      d3.select('#downloadSVG').on('click', downloadSVG)
      d3.select('#loadJSON').on('click', loadJSON)
      d3.select('#loadJSON').on('mouseout', wrongJSONReset)
      d3.select('#lockJSON').on('click', lockJSON)
      d3.select('#updateJSON').on('click', updateJSON)
      d3.select('#lockRendering').on('click', lockRendering)
      d3.select('#updateRendering').on('click', updateRendering)
      d3.select('#save').on('click', save)
      d3.select('#save').on('mouseout', saveReset)
      d3.select('#load').on('click', function(){ d3.event.whichTooltip = d3.select(this).select('.tooltip') })

      d3.select('#saveList')
        .on('click', ()=>{d3.event.stopPropagation()})
        .append('table')

      rerenderSaves()

      d3.selectAll('.help') 
        .datum(function(d,i) {let cL = this.classList; return cL[1] == 'help' ? cL[0] : cL[1]})
        .on('click', function(){ d3.event.whichTooltip = d3.select(this).select('.tooltip') })
      .append('div')
        .html(d => tips[d])
        .classed('tooltip', true)
        .on('click', ()=>{d3.event.stopPropagation()})

      d3.select(document).on('click', tooltipCheck)

      saveArea = d3.select('#saveArea')
    }

    function initSVG() {

      svg = d3.select('#main')
        .style('width', width + 'px')
        .style('height', height + 'px')
      drawing = d3.select('#drawing')
        .attr('transform', `translate(${border} ${border}) scale(${scale})`)
      controls = d3.select('#controls')
        .attr('transform', `translate(${border} ${height - controlHeight - border}) scale(${controlHeight})`)

      //pick initial values
      latticeElements
        .filter(d => d.symmetry == 'cm' && d.lattice == 'Rhombic B')
        .select('input')
        .node().checked = true
      wallpaper = new wallpapers.cm.rhombic_b()

      // draw everything
      restart()
    }

    // â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ  â–ˆ   â–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ   â–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ                             
    // â–ˆ   â–ˆ â–ˆ   â–ˆ â–ˆ   â–ˆ â–ˆ   â–ˆ   â–ˆ   â–ˆâ–ˆ  â–ˆ â–ˆ                                 
    // â–ˆ   â–ˆ â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ â–ˆ â–ˆ   â–ˆ   â–ˆ â–ˆ â–ˆ â–ˆ  â–ˆâ–ˆ                             
    // â–ˆ   â–ˆ â–ˆ   â–ˆ â–ˆ   â–ˆ â–ˆâ–ˆ â–ˆâ–ˆ   â–ˆ   â–ˆ  â–ˆâ–ˆ â–ˆ   â–ˆ                             
    // â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆ   â–ˆ â–ˆ   â–ˆ â–ˆ   â–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ   â–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ  

    // TODO: add options to this
    function restart() {
      prototiles = [new tile(), new tile()]
      rerenderControls()
    }

    // create everything from scratch
    // still don't *quite* grok d3's so-called "standard update pattern"
    function rerender() {
      parqLocs = d3.cross(d3.range(nw), d3.range(nh), (a, b) => 
      ({
        nx: a,
        ny: b
      }))
      edgeGenerator = edgeGeneratorFactory()
      if (parqElements) parqElements.remove()
      parqElements = drawing.selectAll('g')
        .data(parqLocs).enter().append('g')
        .classed('parq', true)
        .attr('transform', wallpaper.tf.bind(wallpaper))
      edgeTfs = wallpaper.edgeTfs()
      if (edgeElements) edgeElements.remove()
      edgeElements = parqElements.selectAll('path')
        .data(loc => edgeData(edgeGenerator((clamp(1, loc.nx, nw-2)-1)/(nw-3)))).enter().append('path')
        .classed('edge', true)
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)
    }

    // when no new elements need to be inserted or removed, we can simply update them
    function reupdate() {
      edgeGenerator = edgeGeneratorFactory()
      if (cmoved) {
        parqElements.attr('transform', wallpaper.tf.bind(wallpaper))
        cmoved = false
      }
      edgeTfs = wallpaper.edgeTfs()
      edgeElements
        .data(loc => edgeData(edgeGenerator((clamp(1, loc.nx, nw-2)-1)/(nw-3))))
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)
    }

    //  â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆ   â–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ  â–ˆ      â–ˆâ–ˆâ–ˆâ–ˆ                       
    // â–ˆ     â–ˆ   â–ˆ â–ˆâ–ˆ  â–ˆ   â–ˆ   â–ˆ   â–ˆ â–ˆ   â–ˆ â–ˆ     â–ˆ                           
    // â–ˆ     â–ˆ   â–ˆ â–ˆ â–ˆ â–ˆ   â–ˆ   â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆ   â–ˆ â–ˆ      â–ˆâ–ˆâ–ˆ                        
    // â–ˆ     â–ˆ   â–ˆ â–ˆ  â–ˆâ–ˆ   â–ˆ   â–ˆ   â–ˆ â–ˆ   â–ˆ â–ˆ         â–ˆ                       
    //  â–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆ   â–ˆ   â–ˆ   â–ˆ   â–ˆ  â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ   

    function rerenderControls() {
      // "prototile" is the term for, not a tile, exactly, but the shape of a tile
      if (prototileElements) prototileElements.remove()
      prototileElements = controls.selectAll('g')
        .data(prototiles).enter().append('g')
        .attr('transform', (d,i,a) => `translate(${i*controlWidth/a.length + 0.25} 0.25) scale(0.5)`)

      // the edges. blue edges are "active" and can be manipulated. black edges are determined by blue edges
      if (ptEdgeElements) ptEdgeElements.remove()
      edgeTfs = wallpaper.edgeTfs()
      ptEdgeElements = prototileElements.selectAll('path')
        .data((pt, i) => edgeData(pt.fullEdges(), i)).enter().append('path')
        .classed('protoedge', true)
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)
      ptEdgeElements.filter(d => !d.tf)
        .classed('active', true)
        .on('mousedown', addVertex)

      // black points determined by the cpoint. at the ends of each edges, if the transforms are correct
      if(ptAnchorElements) ptAnchorElements.remove()
      ptAnchorElements = prototileElements.selectAll('circle.anchor')
        .data(pt => wallpaper.anchors()).enter().append('circle')
        .classed('anchor', true)
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])

      // orange point which controls the shape of the unit
      if (ptCpointElements) ptCpointElements.remove()
      if (wallpaper.cpoint) {
        ptCpointElements = prototileElements.selectAll('circle.cpoint')
          .data(pt => [wallpaper.cpoint]).enter().append('circle')
          .classed('cpoint', true)
          .classed('active', wallpaper.cmove.cursor!='default')
          .style('cursor', wallpaper.cmove.cursor)
          .attr('cx', wallpaper.cpoint[0])
          .attr('cy', wallpaper.cpoint[1])
          .call(cpointDrag)
      }

      // i'm just using vertices to mean the blue points used to manipulate the edges
      if(ptVertexWrappers) {
        ptVertexWrappers.remove()
        ptVertexElements.remove()
      }
      ptVertexWrappers = prototileElements.selectAll('g')
        .data((pt, i) => pt.edges.map(e => assign(e, {ptIndex: i}))).enter().append('g')
      ptVertexElements = ptVertexWrappers.selectAll('circle.vertex')
        .data(e => e.map(v => assign(v, {ptIndex: e.ptIndex}))).enter().append('circle')
        .each(function(d) {d.eIndex = ptVertexWrappers._groups[d.ptIndex].indexOf(this.parentNode)})
        .classed('vertex', true)
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])
        .on('contextmenu', deleteVertex)
        .on('click', 'selectVertex')
        .call(vertexDrag)

      if (liveDrawing) shouldRedraw = Math.max(2, shouldRedraw)
      if (liveSave) updateJSON()
    }

    function reupdateControls() {
      edgeTfs = wallpaper.edgeTfs()
      ptEdgeElements
        .data((pt, i) => edgeData(pt.fullEdges(), i))
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)

      ptAnchorElements
        .data(pt => wallpaper.anchors())
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])

      if (wallpaper.cpoint) {
        ptCpointElements
          .attr('cx', wallpaper.cpoint[0])
          .attr('cy', wallpaper.cpoint[1])
      }

      ptVertexElements
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])

      if (liveDrawing) shouldRedraw = Math.max(1, shouldRedraw)
      if (liveSave) updateJSON()
    }

    function rerenderSaves() {
      if (saveElements) saveElements.remove()
      saveElements = d3.select('#saveList').select('table').selectAll('tr')
        .data(Object.getOwnPropertyNames(saves))
        .enter().append('tr')
      saveElements.append('td')
        .text(d => d)
        .on('click', load)
      saveElements.append('td')
        .on('click', deleteSave)
        .on('mouseOut', deleteReset)
    }

    // â–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ   â–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆ 
    // â–ˆ       â–ˆ   â–ˆ       â–ˆ   â–ˆ     â–ˆâ–ˆ  â–ˆ â–ˆ     â–ˆ   â–ˆ â–ˆ     
    // â–ˆ       â–ˆ    â–ˆâ–ˆâ–ˆ    â–ˆ   â–ˆâ–ˆâ–ˆ   â–ˆ â–ˆ â–ˆ â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆâ–ˆ   â–ˆâ–ˆâ–ˆ  
    // â–ˆ       â–ˆ       â–ˆ   â–ˆ   â–ˆ     â–ˆ  â–ˆâ–ˆ â–ˆ     â–ˆ   â–ˆ     â–ˆ 
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ    â–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ   â–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ   â–ˆ â–ˆâ–ˆâ–ˆâ–ˆ  

    function dragVertex(d, i, g) {
      d[0] = d3.event.x
      d[1] = d3.event.y
      document.execCommand('undo')
      reupdateControls()
    }
    function dragCpoint(d, i, g) {
      wallpaper.cpoint.splice(0, 2, ...wallpaper.cmove(d3.event.x, d3.event.y))
      cmoved = true
      document.execCommand('undo')
      reupdateControls()
    }

    function addVertex(d, i, g) {
      const point = clientToLocal(d3.event, this)
      const dist = distanceAlongPath(this, clientToLocal(d3.event, this))
      const edge = prototiles[d.ptIndex].fullEdges()[i]
      let j = 0
      while (distanceAlongPath(this, edge[j]) < dist && j < edge.length) j++
      for (let k=0; k < prototiles.length; k++) {
        let fulledge = prototiles[k].fullEdges()[i]
        let newVertex = k == d.ptIndex?
          [point.x, point.y]:
          d3.interpolate(fulledge[j-1],fulledge[j])(0.5)
        prototiles[k].edges[i].splice(j-1,0,newVertex)
      }
      rerenderControls()
      let newVertex = ptVertexWrappers._groups[d.ptIndex][i].children[j-1]
      d3.select(newVertex).dispatch('mouseup')
      // <selection>.dispatch creates a custom event which doesn't have the "view" property
      // d3.drag requires event.view, so we do this "properly" instead
      let mouseDown = new MouseEvent('mousedown',
        {view: window, bubbles: true, cancelable: true}
      );
      newVertex.dispatchEvent(mouseDown)
    }
    function deleteVertex(d, i, g) {
      let e = d3.event
      e.preventDefault()
      for (let k=0; k < prototiles.length; k++) {
        prototiles[k].edges[d.eIndex].splice(i, 1)
      }
      rerenderControls()
    }

    function tooltipCheck() {
      let tooltip = d3.event.whichTooltip
      let wasAlreadyDisplayed = true
      if (tooltip) wasAlreadyDisplayed = tooltip.style('display') == 'block'
      d3.selectAll('.tooltip').style('display', 'none')
      if (!wasAlreadyDisplayed) tooltip.style('display', 'block')
    }

    function downloadSVG() {
      let svgRect = svg.node().getBoundingClientRect()
      let gRect = drawing.node().getBoundingClientRect()
      let w = Math.round(gRect.width + 2*border)
      let h = Math.round(gRect.height + 2*border)
      let x = Math.round((gRect.x-border)-svgRect.x)
      let y = Math.round((gRect.y-border)-svgRect.y)
      let prefix = '<?xml version="1.0" standalone="no"?>\n'
      +'<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
      +`<svg viewBox="${x} ${y} ${w} ${h}" width="${w}" height="${h}" `
      +'xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink">\n'
      let blob = new Blob(
        [prefix, drawing.node().outerHTML.replace(/(\.\d{4})\d*/g, '$1'),
        d3.select('style#parqStyle').node().outerHTML, '\n</svg>'], {type: 'image/svg+xml'})
      saveAs(blob, 'parquet.svg')
    }

    function loadJSON() {
      try {
        deformation = JSON.parse(saveArea.node().value)
        name = deformation.name || 'parquet'
        wallpaper = new wallpapers[deformation.symmetry][deformation.lattice]()
        if (wallpaper.cpoint) wallpaper.cpoint = wallpaper.cmove(...deformation.cpoint)
        prototiles = deformation.tiles.map(t => new tile(t))
        let livingSave = liveSave
        liveSave = false
        rerenderControls()
        liveSave = livingSave
        wrongJSONReset.bind(this)()
      } catch (e) {
        this.classList.add('error')
      }
    }
    function wrongJSONReset() {
      this.classList.remove('error')
    }
    function lockJSON() {
      if (liveSave) {
        liveSave = false
        this.innerText = 'ðŸ”’'
      } else {
        liveSave = true
        this.innerText = 'ðŸ”“'
      }
    }
    function updateJSON(t) {
      let textarea = saveArea.node()
      textarea.select()
      supportsCommand = document.execCommand('insertText', false, saveString())
      if (!supportsCommand) textarea.value = saveString()
    }

    function lockRendering() {
      if (liveDrawing) {
        liveDrawing = false
        this.innerText = "ðŸ”’"
        this.previousElementSibling.removeAttribute('disabled')
      } else {
        liveDrawing = true
        this.innerText = "ðŸ”“"
        this.previousElementSibling.setAttribute('disabled', '')
      }
    }
    function updateRendering() {
      reupdate()
    }

    function save() {
      loadJSON.bind(this)()
      if (name === '') name = 'parquet'
      if (saves.hasOwnProperty(name) && !saveConfirm) {
        saveConfirm = true
        this.innerText = 'Replace?'
      } else {
        saves[name] = saveArea.node().value.replace(/ /g, '')
        localStorage.setItem('deformations', JSON.stringify(saves))
        rerenderSaves()
        saveConfirm = false
        this.innerText = 'Saved!'
      }
    }
    function saveReset() {
      saveConfirm = false
      this.innerText = 'Save'
    }
    function load(d) {
      let textarea = saveArea.node()
      textarea.select()
      supportsCommand = document.execCommand('insertText', false, saves[d])
      if (!supportsCommand) textarea.value = saves[d]
      loadJSON()
    }
    function deleteSave(d) {
      if (!deleteConfirm) {
        deleteConfirm = true
        this.classList.add('confirm')
      } else {
        deleteConfirm = false
        delete saves[d]
        localStorage.setItem('deformations', JSON.stringify(saves))
        rerenderSaves()
      }
    }
    function deleteReset() {
      deleteConfirm = false
      this.classList.remove('confirm')
    }

    // â–ˆ   â–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆâ–ˆ                 
    // â–ˆ   â–ˆ   â–ˆ     â–ˆ   â–ˆ       â–ˆ     â–ˆ     â–ˆ   â–ˆ     â–ˆ                     
    // â–ˆ   â–ˆ   â–ˆ     â–ˆ   â–ˆ       â–ˆ     â–ˆ     â–ˆ   â–ˆâ–ˆâ–ˆ    â–ˆâ–ˆâ–ˆ                  
    // â–ˆ   â–ˆ   â–ˆ     â–ˆ   â–ˆ       â–ˆ     â–ˆ     â–ˆ   â–ˆ         â–ˆ                 
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ   â–ˆ   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆâ–ˆâ–ˆâ–ˆ  

    function edgeGeneratorFactory() {
      return d3.piecewise(d3.interpolate, prototiles.map(t => t.fullEdges()))
    }

    //TODO: pretty sure D3 has a way to handle this
    function clientToLocal(e, svgEl) {
      let point = svg.node().createSVGPoint()
      point.x = e.clientX; point.y = e.clientY
      point = point.matrixTransform(svgEl.getScreenCTM().inverse())
      return point
    }

    function distanceAlongPath(path, point) {
      const length = path.getTotalLength()
      const delta = length/1024
      let i = 0
      let best, bestDist = length**2

      if (Array.isArray(point)) {
        let temppoint = svg.node().createSVGPoint()
        temppoint.x = point[0]; temppoint.y = point[1]
        point = temppoint
      }

      while (i < 1024 && bestDist > delta**2) {
        let point2 = path.getPointAtLength(i*delta)
        let dist = (point.x-point2.x)**2 + (point.y-point2.y)**2
        if (dist > (64*delta)**2) i+=64
        else if (dist > (8*delta)**2) i+=8
        else i += 1
        if (dist < bestDist) {
          bestDist = dist
          best = i
        }
      }
      return best*delta
    }

    function edgeData(edges, ptIndex=-1) {
      edges = edges.map(edgeHelper)
      let result = []
      for (let i=0; i<wallpaper.edgeEnds.length; i++) {
        for (let j=0; j<edgeTfs[i].length; j++) {
          result.push({
            tf: edgeTfs[i][j],
            data: edges[i],
            ptIndex: ptIndex
          })
        }
      }
      return result
    }

    // creates JSON representation of all relevant data
    function saveString() {
      let lattice = wallpaper.constructor;
      let symmetry
      for (let sym in wallpapers) {
        if (wallpapers[sym][lattice.name] === lattice) {
          symmetry = sym; break
        }
      }

      // arrow function does 1.7320508075688772 -> " 1.7321"
      result = JSON.stringify(
        {name: name, symmetry: symmetry, lattice: lattice.name, cpoint: wallpaper.cpoint, tiles: prototiles.map(t => t.edges)},
        (key, val) => (exists(val) && val.toFixed)? val.toFixed(4).replace(/[0.](?=0*$)/g,' ').replace(/^(?=\d)/, ' ') : val,
        2
      )
      result = result
        .replace(/"(-? ?\d+(\.\d*)? *)"/g, '$1')                              // quoted numbers to actual numbers
        .replace(/( *)\[\n *?(-? ?\d.*)\n *?(-? ?\d.*)\n *\]/g, '$1[$2 $3]')  // each point to single line
        .replace(/( {8}.*\n)(?= {8})/g,'$1~').replace(/\n~ */g, ' ')          // all points in each edge to same line
        .replace(/\n {6}\[\n {8}(.*)\n {6}\]/g, '\n      [$1]')   // each edge to single line
        .replace(/( {6})(\[\]),\n(?=\1\2)/g, '$1$2, ')            // consecutive empty edges to same line
        .replace(/([^\n ]) {7}/g, '$1 ')                          // get rid of extra spaces from previous step
        .replace(/\n {4}\[\n {6}(.*)\n {4}\]/g, '\n    [$1]')     // "small" tiles to single line
        .replace(/  \],\n *\[\n/g, '  ], [\n')                    // "],[" between "big" arrays to single line
        .replace(/{\n(  .*)\n ( .*)\n ( .*)/, '{\n$1$2$3')        // non-"tiles" props to single line
      // I know it's a lot of junk but it makes the JSONs look super nice so I don't care
      return result
    }

    function clamp (a, val, b) {
      return Math.max(a, Math.min(val, b))
    }

    function indexOf(that, e) {
      return Array.prototype.indexOf.call(that, e)
    }

    function exists (val) {
      return val !== null && val !== undefined
    }
  </script>
</body>
</html>
