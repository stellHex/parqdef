
<!doctype html>

<html lang='en'>
<meta charset='utf-8'>
<title>Parquet Deformation: I at the Center</title>
<meta content='D3 parquet deformation creator.' name='description'>
<style>
  
  #inprogress {
    display: none;
    position: absolute;
    top: 200px;
    left: 300px;
    font-size: 40px;
  }

</style>
<body>
  <div id='inprogress'>
    Building...
  </div>
  
  <svg>
    <g id='drawing'>
    </g>
  </svg>
  
  <script src='http://d3js.org/d3.v4.min.js'></script>
  <script src='https://d3js.org/d3-array.v1.min.js'></script>
  <script src='https://d3js.org/d3-shape.v1.min.js'></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>

  <script>
    var svg, drawing // should be defined by init
    var shouldRedraw = true
  
    var nw = 23, nh = 11
    var border = 50
    var width = 1200, scale = (width - border*2)/(1.5*nw), height = scale*nh + border*2, center = [width/2, height/2];
    
  
    var edgeHelper = d3.line()

    var prototiles // defined by restart
    var parqLocs // defined by reparameterize
    var edgeGenerator, parqElements, edgeElements // defined by rerender

    const archetype = {
      square: {

      }
    }
    // note: inconsistent use of arrow functions and `function()` functions, because I don't like using `function()` functions
    // in compact definitions like this, but they're neccesary because `this` can't be rebound on arrow functions
    const wallpapers = {
      p1: {
        square: function() {
          this.cpoint = [1, 1] // control point. in the future may be variable between tiles
          this.cmove = (x,y) => [1, 1] // how the cpoint changes if it is dragged to x,y
          this.anchors = function () {[[0, 0], [1, 0], this.cpoint, [0, 1]]} // corners
          this.edgeEnds = [
            [1, 2], // values are indices of this.anchors
            [2, 3]  // if variable cpoints implemented, will instead be indices of tile.anchors
          ]
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', 'translate(0 -1)']]
          this.tf = d => `translate(${d.nx} ${d.ny})`
        },
        rectangular: function() {
          Object.assign(this, new wallpapers.p1.square())
          this.cmove = (x,y) => [x,1]
          this.anchors =  function () {return [[0, 0], [this.cpoint[0], 0], this.cpoint, [0, 1]]}
          this.edgeTfs = () => [['', `translate(-${this.cpoint[0]} 0)`], ['', 'translate(0 -1)']]
          this.tf = d => `translate(${this.cpoint[0]*d.nx} ${d.ny})`
        },
        oblique: function() {
          Object.assign(this, new wallpapers.p1.square())
          this.cmove = (x,y) => [x,y]
          this.anchors =  () => [[0, 0], [1, 0], this.cpoint, [this.cpoint[0]-1, this.cpoint[1]]]
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', `translate(${1-this.cpoint[0]} -${this.cpoint[1]})`]]
          this.tf = d => `translate(${d.nx + (this.cpoint[0]%1)*d.ny} ${this.cpoint[1] * d.ny})`
        },
        hexagonal: function() {
          this.cpoint = [Math.sqrt(3), 0.5]
          this.cmove = (x,y) => [this.cpoint[0],0.5] // faster than calc'ing sqrt(3) again
          this.anchors =  () => [[0, 0.5], [this.cpoint[0]/2, 0], this.cpoint, [this.cpoint[0]/2, 1]]
          this.edgeEnds = [[1, 2], [2, 3]],
          this.edgeTfs = () => [['',`translate(-${this.cpoint[0]/2} 0.5)`],['',`translate(-${this.cpoint[0]/2} -0.5)`]]
          this.tf = d => `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2})`
        },
        rhombic: function() {
          Object.assign(this, new wallpapers.p1.hexagonal())
          this.cmove = (x,y) => [x,0.5]
        }
      },
      p2: {
        square: function() {
          this.cpoint = [1,1]
          this.cmove = (x,y) => [1,1]
          this.anchors = () => [[0, 0], [0.5, 0], [1, 0], [1, 0.5], [1, 1], [0.5, 1], [0, 1], [0, 0.5]]
          this.edgeEnds = [[0,1],[2,3],[4,5],[6,7]]
          this.edgeTfs = function () {a = this.anchors(); return Array.from({length:4}, (e,i) => ['', `rotate(180 ${a[i*2+1]})`])}
          this.tf = d => `translate(${d.nx} ${d.ny}) rotate(${(d.nx+d.ny)%2 * 180} 0.5 0.5)`
        },
        rectangular: function() {
          Object.assign(this, new wallpapers.p2.square())
          this.cmove = (x,y) => [x,1]
          this.anchors = () => {let x=this.cpoint[0]; return [[0, 0], [x/2, 0], [x, 0], [x, 0.5], [x, 1], [x/2, 1], [0, 1], [0, 0.5]]}
          this.tf = d => `translate(${d.nx*this.cpoint[0]} ${d.ny}) rotate(${(d.nx+d.ny)%2 * 180} ${this.cpoint[0]/2} 0.5)`
        },
        oblique: function() {
          Object.assign(this, new wallpapers.p2.square())
          this.cmove = (x,y) => [x,y]
          this.anchors = () => {let x=this.cpoint[0]; let y=this.cpoint[1];
            return [[0, 0], [0.5, 0], [1, 0], [x/2+0.5, y/2], [x, y], [x-0.5, y], [x-1, y], [(x-1)/2, y/2]]}
          this.tf = d => {let x=this.cpoint[0]; let y=this.cpoint[1];
            return `translate(${d.nx + (x%1)*d.ny} ${y*d.ny}) rotate(${(d.nx+d.ny)%2 * 180} ${x/2} ${y/2})`}
        },
        hexagonal: function() {
          this.cpoint = [Math.sqrt(3), 0.5]
          this.cmove = (x,y) => [this.cpoint[0],0.5]
          this.anchors = function() {let x=this.cpoint[0];
            return [[0, 0.5], [x*0.25, 0.25], [x*0.5, 0], [x*0.75, 0.25], [x, 0.5], [x*0.75, 0.75], [x*0.5, 1], [x*0.25, 0.75]]}
          this.edgeEnds = [[0,1],[2,3],[4,5],[6,7]]
          this.edgeTfs = function() {a = this.anchors(); return Array.from({length:4}, (e,i) => ['', `rotate(180 ${a[i*2+1]})`])}
          this.tf = function(d) {return 
            `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2}) rotate(${d.nx%2 * 180} ${this.cpoint[0]/2} 0.5)`}
        },
        rhombic: function() {
          Object.assign(this, new wallpapers.p2.hexagonal())
          this.cmove = (x,y) => [x,0.5]
        }
      },
      pm: {},
      pg: {
        square_a: function() {
          Object.assign(this, new wallpapers.p1.square())
          this.edgeTfs = () => [['', 'translate(-1 1) scale(1 -1)'], ['', 'translate(0 -1)']],
          this.tf = d => `translate(${d.nx} ${d.ny+d.nx%2}) ${d.nx%2?'scale(1 -1)':''}`
        },
        square_b: function() {
          Object.assign(this, new wallpapers.p1.square())
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', 'translate(1 -1) scale(-1 1)']],
          this.tf = d => `translate(${d.nx+d.ny%2} ${d.ny}) ${d.ny%2?'scale(-1 1)':''}`
        },
        rectangular_a: function() {
          Object.assign(this, new wallpapers.p1.rectangular())
          this.edgeTfs = () => [['', `translate(-${this.cpoint[0]} 1) scale(1 -1)`], ['', 'translate(0 -1)']],
          this.tf = d => `translate(${this.cpoint[0]*d.nx} ${d.ny+d.nx%2}) ${d.nx%2?'scale(1 -1)':''}`
        },
        rectangular_b: function() {
          Object.assign(this, new wallpapers.p1.rectangular())
          this.edgeTfs = () => [['', `translate(-${this.cpoint[0]} 0)`], ['', `translate(${this.cpoint[0]} -1) scale(-1 1)`]],
          this.tf = d => `translate(${this.cpoint[0]*(d.nx+d.ny%2)} ${d.ny}) ${d.ny%2?'scale(-1 1)':''}`
        },
      },
      cm: {}, pmm: {},
      pmg: {

      }

      p6: {
        hexagonal_a(): {} // 1 edge with 12 tfs (hexagon)
        hexagonal_b(): {} // 1 edge with 6 tfs (triangle)
        hexagonal_c(): {} // 1 edge with 4 tfs (rhombus)
      },
      p6m: {}
    }

    var wallpaper = new wallpapers.pg.rectangular_a()
    wallpaper.cpoint = [1.5,1]

    init()
    
    // p1.rhombic
    // prototiles[0].edges = [[[Math.sqrt(3)/2, 0.5]], [[Math.sqrt(3)/2, 0.5]]]
    // prototiles[1].edges = [[[Math.sqrt(3),0]], [[Math.sqrt(3), 1]]]
    // p2.square
    prototiles[0].edges[0] = [[1.25,0]]
    prototiles[1].edges[0] = [[1.25,1]]
    rerender()

    d3.interval(function(dt) {
      if (shouldRedraw) {
        edgeElements.attr('d', d => d.data)
        shouldRedraw = false
      }
    });

    function init() {
      svg = d3.select('svg')
        .attr('width', width)
        .attr('height', height)

      drawing = d3.select('#drawing')
        .attr('transform', `translate(${border},${border}) scale(${scale})`)
      
      restart()
    }

    function restart() {
      prototiles = [new tile(), new tile()]
      reparameterize()
    }

    function reparameterize() {
      parqLocs = d3.cross(d3.range(nw), d3.range(nh), (a, b) => 
      ({
        nx: a,
        ny: b
      }))
      rerender()
    }

    function rerender() { //inefficient -- don't need to recreate all elements every time
      edgeGenerator = edgeGeneratorFactory()
      if (parqElements) parqElements.remove()
      parqElements = drawing.selectAll('g')
        .data(parqLocs).enter().append('g')
        .attr('class', 'parq')
        .attr('transform', wallpaper.tf)
      let edgeTfs = wallpaper.edgeTfs()
      edgeElements = parqElements.selectAll('path')
        .data(loc => {
          let result = []
          let clampedx = Math.min(Math.max(loc.nx-1, 0), nw-3)
          let edges = edgeGenerator(clampedx/(nw-3)).map(edgeHelper)
          for (let i=0; i<wallpaper.edgeEnds.length; i++) {
            for (let j=0; j<edgeTfs[i].length; j++) {
              result.push({
                tf: edgeTfs[i][j],
                data: edges[i]
              })
            }
          }
          return result
        }).enter().append('path')
        .attr('stroke', 'black')
        .attr('stroke-width', 0.05)
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)
        .attr('fill', 'none')
    }

    function tile(edges) {
      this.anchors = wallpaper.anchors()
      this.edges = edges || Array.from({length: wallpaper.edgeEnds.length}, () => [])
      this.fullEdges = function() {
        result = []
        for (let i=0; i<wallpaper.edgeEnds.length;i++) {
          result.push([this.anchors[wallpaper.edgeEnds[i][0]]].concat(this.edges[i], [this.anchors[wallpaper.edgeEnds[i][1]]]))
        }
        return result
      }
    }

    function edgeGeneratorFactory() {
      return d3.piecewise(d3.interpolate, prototiles.map(t => t.fullEdges()))
    }

    function oldinit() {
      svg = d3.select('svg')
        .attr('width', width)
        .attr('height', height);

      drawing = d3.select('#drawing')
        .attr('transform', 'translate('+center+')');
      
      parqElements = drawing.selectAll('path')
        .data(allparqsOnMe).enter().append('path')
        .attr('class', 'parq')
        .attr('stroke', '#832')
        .attr('fill', d => d.r ? '#e95':'#c74')
        .attr('stroke-width', 2)
        .attr('transform', d =>  (d.r ? ' rotate(90 '+d.xy+')':'') + 'translate('+d.xy+')')
        .attr('d', d => parqGenerator(parqShape(d)));

      drawing.on('touchmove mousemove', moved)
        .on('mouseout', exited)
        .on('click', clicked)
        .on('enter', entered);
    }

    function bookbind(paper) {
      paper.cmove.bind
    }

    function moved() {
      if (smooving < 0) {
        var crd = d3.mouse(this)
        mousencoords = [crd[0]/width*nw, crd[1]/height*nh]
        shouldRedraw = true
      }
    }

    function entered() {
    }
    
    function clicked() {
      rotate = !rotate
    }

  </script>
</body>
</html>
