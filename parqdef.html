
<!doctype html>

<html lang='en'>
<meta charset='utf-8'>
<title>Parquet Definition</title>
<meta content='D3 parquet deformation creator.' name='description'>
<style>
  * {
    font-family: monospace;
  }

  #wpWrapper {
    background-color: black;
    padding: 3px;
  }
  #wpDisplay {
    width: 200px;
    border-collapse: collapse;
  }

  .wpGroup:nth-child(2n-1) {background-color: lightgray;}
  .wpGroup:nth-child(2n) {background-color: whitesmoke;}

  tfoot.wpGroup td {
    text-align: center;
    padding: 3px 0;
  }
  
  .wpVariant {display: table-row;}
  .wpVariant:hover {outline: 3px solid rgba(100, 100, 255, 0.75);}
  .wpVariant input {display: none;}

  #wpDisplay td {
    padding-left: 2px; padding-right: 2px;
    border-collapse: collapse;
  }
  .wpSymmetry, .wpLattice {text-align: right;}
  .wpHint {text-align: center;}
  .wpHint code {
    display: block;
    border: 1px solid black;
    padding: 1px;
    padding-top: 0px;
    padding-bottom: 2px;
    background-color: white;
  }
  input:checked ~ * {
    font-weight: bold;
    background-color: #49f;
    color: white;
  }
  input:checked ~ .wpHint code {
    background-color: midnightblue;
    border-color: #49f;
  }

  .aligntop {vertical-align: top;}

  #buttons {
    display: grid;
    grid-template: 1fr 1fr 1fr 1fr 1fr / 1fr 1fr 1fr 1fr 25px;
    grid-gap: 3px;
  }
  button.span4 {grid-column-end: span 4;}
  button.span3 {grid-column-end: span 3;}
  button.span2 {grid-column-end: span 2;}
  button.help.JSON {grid-row-end: span 2;}
  button.help {
    padding: 2px 6px;
    border-radius: 1000px;
    border: 1px #dadada solid;
    outline: none;
    position: relative;
    place-self: center;
  }
  /* button styles swiped from google */
  button {
    color: #333333;
    background: #f3f3f3;
    border: 1px #dadada solid;
    padding: 5px 10px;
    border-radius: 2px;
    font-weight: bold;
    font-size: 9pt;
    outline: none;
    cursor: default;
    user-select: none;
  }
  button:hover:not(:disabled) {
    border: 1px #c6c6c6 solid;
    box-shadow: 1px 1px 1px #eaeaea;
    color: #222;
    background: #f7f7f7;
  }
  button:active {
    box-shadow: inset 1px 1px 1px #dfdfdf;   
  }
  button:disabled {
    color: #999;
    background: #fff;
  }
  /* super simple tooltips swiped from what-if.xkcd.com */
  .tooltip {
    display: none;
    position: absolute;
    left: 25px;
    bottom: -10px;
    border: 1px solid black;
    padding: 5px;
    background-color: #fff;
    transform: translateZ(1px);
    white-space:normal;
    word-wrap: break-word;
    min-width: 300px;
    z-index: 9999;
    overflow: auto;
    cursor: auto;
    user-select: text;
  }

  #saveArea {
    margin: 10px;
    resize: vertical;
    width: 75%;
  }
</style><style id='controlStyle'>
  path.protoedge {
    stroke: #444;
    stroke-width: 0.04;
    fill: none;
  }
  path.protoedge.active {
    stroke: blue;
    cursor: copy;
  }

  circle.anchor {
    fill: black;
    r: 0.06;
  }
  circle.cpoint {
    stroke-width: 0.025;
    stroke: black;
    fill: gray;
    r: 0.07;
  }
  circle.cpoint.active {
    stroke: #c00;
    fill: #f90;
  }
  circle.vertex {
    stroke-width: 0.025;
    stroke: #00a;
    fill: #88f;
    cursor: move;
    r: 0.07;
    opacity: 0.9
  }
</style>
<style id='parqStyle'>
  path.edge {
    stroke: black;
    stroke-width: 0.05;
    fill: none;
  }
</style>
<body>
  <table>
    <tr>
      <td><nobr><div id='wpWrapper'>
        <table id='wpDisplay'>
          <tfoot class='wpGroup'>
            <td><button class='help wallpapers'>?</button></td>
            <td><button class='help lattices'>?</button></td>
            <td><button class='help mnemonics'>?</button></td>
          </tfoot>
        </table>
      </div></nobr></td>
      <td><svg id='main'>
        <g id='drawing'></g>
        <g id='controls'></g>
      </svg></td>
    </tr>
    <tr>
      <td class='aligntop'><div id='buttons'>
          <button id='downloadSVG' class='span4'>Download SVG</button>
          <button class='help download'>?</button>
          <button id='loadJSON' class='span4'>Load From JSON</button>
          <button class='help JSON'>?</button>
          <button id='lockJSON' class='span3'>Lock JSON</button>
          <button id='updateJSON'>⟳</button>
          <button id='lockRendering' class='span3'>Lock Rendering</button>
          <button id='updateRendering' disabled>⟳</button>
          <button class='help rendering'>?</button>
          <button id='save' class='span2'>Save</button>
          <button id='load' class='span2'>Load...</button>
          <button class='help storage'>?</button>
      </div></td>
      <td>
        <textarea id='saveArea' rows=10></textarea>
      </td>
    </tr>
  </table>
  
  <script src='http://d3js.org/d3.v4.js'></script>
  <script src="https://d3js.org/d3-drag.v1.min.js"></script>
  <script src='https://d3js.org/d3-array.v1.min.js'></script>
  <script src='https://d3js.org/d3-shape.v1.js'></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
  <script src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/14082/FileSaver.js"></script>

  <script>

    /*****************\
    |*               *|
    |*  SCAFFOLDING  *|
    |*               *|
    \*****************/

    var wpDisplay, symmetryElements, latticeElements, helpElements, saveArea,
      svg, drawing, controls // defined by init
    var shouldRedraw = false
    var cmoved = false
  
    var liveSave = true
    var liveDrawing = true

    var nw = 23, nh = 11
    var border = 30, width = 1200, controlHeight = 150, controlWidth = width/controlHeight
    var scale = (width - border*2)/(1.5*nw), height = scale*nh + controlHeight + border*3
    
    // creates svg path data strings from lists of points
    const edgeHelper = d3.line()

    const assign = Object.assign  

    var parqLocs, prototiles // defined by restart
    var parqElements, edgeElements // defined by rerender
    var edgeGenerator // defined by rerender AND reupdate
    var edgeTfs // defined by many things

    var prototileElements, ptEdgeElements, ptCpointElements, ptAnchorElements,
      ptVertexWrappers, ptVertexElements // defined by rerenderControls

    const tips = {
      wallpapers: 'These are the <a href="https://en.wikipedia.org/wiki/Wallpaper_group">wallpaper groups</a>. They determine the symmetry of the resulting tesselation. There are 17 in total; not all of them are present due to technical limitations with the implementation, but there\'s still plenty of variety. Experiment!',
      lattices: 'These are the lattices of the tesselation, or how the centers of the tiles are arranged. Some wallpaper groups allow for multiple lattices, and some do not. Since the orientation of the symmetry matters for parquet deformations, many of the group/lattice pairs are included multiple times.',
      mnemonics: 'These are mnemonics to try to show what using the specific variant will look like.',
      download: 'SVG is an image format which can be displayed by any modern browser. It\'s a vector format, which means it stores shapes and positions instead of pixels. If you want a png instead, take a screenshot using the Snipping Tool on Windows and Shift-Command-4 on Mac.',
      JSON: 'JSON is a data storage format which is used to store your deformation. It\'s displayed just to the right; with a bit of experimentation, it should be pretty clear how it works. You can modify the JSON and then load from it for precision in placing your points. If you want to mess with the prototiles without disturbing your JSON, you can lock it, and click the "⟳" button if you want to update it.',
      rendering: 'If your computer struggles to keep up whenever you change the prototiles, then it may be a good idea to lock the rendering, and click the "⟳" button when you make an adjustment.',
      storage: 'These buttons save and load the parquet deformations locally in your browser.'
    }

    const rt3 = Math.sqrt(3)
    const third = 1/3

    // note: inconsistent use of arrow functions and `function()` functions, because I prefer arrow functions in
    // crowded definitions like this, but sometimes they can't be used because their `this` can't be rebound
    const wallpapers = {
      p1: {
        square: function() {
          this.cpoint = [1, 1] // control point. in the future may be variable between tiles
          this.cmove = (x,y) => [1, 1]; this.cmove.cursor = 'default' // how the cpoint changes if it is dragged to x,y
          this.anchors = function () {return [[0, 0], [1, 0], this.cpoint, [0, 1]]} // corners
          this.edgeEnds = [
            [1, 2], // values are indices of this.anchors
            [2, 3]  // if variable cpoints implemented, will instead be indices of tile.anchors
          ]
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', 'translate(0 -1)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny})`}
        },
        rectangular: function() {
          assign(this, new wallpapers.p1.square())
          this.cmove = (x,y) => [x,1]; this.cmove.cursor = 'ew-resize'
          this.anchors = function () {return [[0, 0], [this.cpoint[0], 0], this.cpoint, [0, 1]]}
          this.edgeTfs = () => [['', `translate(-${this.cpoint[0]} 0)`], ['', 'translate(0 -1)']]
          this.tf = function(d) {return `translate(${this.cpoint[0]*d.nx} ${d.ny})`}
        },
        oblique: function() {
          assign(this, new wallpapers.p1.square())
          this.cmove = (x,y) => [x,y]; this.cmove.cursor = 'move'
          this.anchors = () => [[0, 0], [1, 0], this.cpoint, [this.cpoint[0]-1, this.cpoint[1]]]
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', `translate(${1-this.cpoint[0]} -${this.cpoint[1]})`]]
          this.tf = function(d) {return `translate(${d.nx + (this.cpoint[0]%1)*d.ny} ${this.cpoint[1] * d.ny})`}
        },
        hexagonal: function() {
          this.cpoint = [Math.sqrt(3), 0.5]
          this.cmove = (x,y) => [this.cpoint[0],0.5]; this.cmove.cursor = 'default'
          this.anchors = function () {return [[0, 0.5], [this.cpoint[0]/2, 0], this.cpoint, [this.cpoint[0]/2, 1]]}
          this.edgeEnds = [[1, 2], [2, 3]],
          this.edgeTfs = () => [['',`translate(-${this.cpoint[0]/2} 0.5)`],['',`translate(-${this.cpoint[0]/2} -0.5)`]]
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2})`}
        },
        rhombic: function() {
          assign(this, new wallpapers.p1.hexagonal())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      p2: {
        square: function() {
          this.cpoint = [1,1]
          this.cmove = (x,y) => [1,1]; this.cmove.cursor = 'default'
          this.anchors = () => [[0, 0], [0.5, 0], [1, 0], [1, 0.5], [1, 1], [0.5, 1], [0, 1], [0, 0.5]]
          this.edgeEnds = [[0,1],[2,3],[4,5],[6,7]]
          this.edgeTfs = function () {let a = this.anchors(); return Array.from({length:4}, (e,i) => ['', `rotate(180 ${a[i*2+1]})`])}
          this.tf = function(d) {return `translate(${d.nx} ${d.ny}) rotate(${(d.nx+d.ny)%2 * 180} 0.5 0.5)`}
        },
        rectangular: function() {
          assign(this, new wallpapers.p2.square())
          this.cmove = (x,y) => [x,1]; this.cmove.cursor = 'ew-resize'
          this.anchors = function () {let x=this.cpoint[0]; return [[0, 0], [x/2, 0], [x, 0], [x, 0.5], [x, 1], [x/2, 1], [0, 1], [0, 0.5]]}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]} ${d.ny}) rotate(${(d.nx+d.ny)%2 * 180} ${this.cpoint[0]/2} 0.5)`}
        },
        oblique: function() {
          assign(this, new wallpapers.p2.square())
          this.cmove = (x,y) => [x,y]; this.cmove.cursor = 'move'
          this.anchors = () => {let x=this.cpoint[0]; let y=this.cpoint[1];
            return [[0, 0], [0.5, 0], [1, 0], [x/2+0.5, y/2], [x, y], [x-0.5, y], [x-1, y], [(x-1)/2, y/2]]}
          this.tf = function(d) {let x=this.cpoint[0]; let y=this.cpoint[1];
            return `translate(${d.nx + (x%1)*d.ny} ${y*d.ny}) rotate(${(d.nx+d.ny)%2 * 180} ${x/2} ${y/2})`}
        },
        hexagonal: function() {
          this.cpoint = [Math.sqrt(3), 0.5]
          this.cmove = (x,y) => [this.cpoint[0],0.5]; this.cmove.cursor = 'default'
          this.anchors = function() {let x=this.cpoint[0];
            return [[0, 0.5], [x*0.25, 0.25], [x*0.5, 0], [x*0.75, 0.25], [x, 0.5], [x*0.75, 0.75], [x*0.5, 1], [x*0.25, 0.75]]}
          this.edgeEnds = [[0,1],[2,3],[4,5],[6,7]]
          this.edgeTfs = function() {a = this.anchors(); return Array.from({length:4}, (e,i) => ['', `rotate(180 ${a[i*2+1]})`])}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2}) rotate(${d.nx%2 * 180} ${this.cpoint[0]/2} 0.5)`}
        },
        rhombic: function() {
          assign(this, new wallpapers.p2.hexagonal())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      pm: {},
      pg: {
        square_a: function() {
          assign(this, new wallpapers.p1.square())
          this.edgeTfs = () => [['', 'translate(-1 1) scale(1 -1)'], ['', 'translate(0 -1)']],
          this.tf = function(d) {return `translate(${d.nx} ${d.ny+d.nx%2}) ${d.nx%2?'scale(1 -1)':''}`}
        },
        square_b: function() {
          assign(this, new wallpapers.p1.square())
          this.edgeTfs = () => [['', 'translate(-1 0)'], ['', 'translate(1 -1) scale(-1 1)']],
          this.tf = function(d) {return `translate(${d.nx+d.ny%2} ${d.ny}) ${d.ny%2?'scale(-1 1)':''}`}
        },
        rectangular_a: function() {
          assign(this, new wallpapers.p1.rectangular())
          this.edgeTfs = () => [['', `translate(-${this.cpoint[0]} 1) scale(1 -1)`], ['', 'translate(0 -1)']],
          this.tf = function(d) {return `translate(${this.cpoint[0]*d.nx} ${d.ny+d.nx%2}) ${d.nx%2?'scale(1 -1)':''}`}
        },
        rectangular_b: function() {
          assign(this, new wallpapers.p1.rectangular())
          this.edgeTfs = () => [['', `translate(-${this.cpoint[0]} 0)`], ['', `translate(${this.cpoint[0]} -1) scale(-1 1)`]],
          this.tf = function(d) {return `translate(${this.cpoint[0]*(d.nx+d.ny%2)} ${d.ny}) ${d.ny%2?'scale(-1 1)':''}`}
        },
      },
      cm: {
        square: function() {
          assign(this, new wallpapers.p1.square())
          this.edgeEnds = [[1,2]]
          this.edgeTfs = () => [['', 'translate(-1 0)', 'scale(-1 1) rotate(-90 0 1)', 'scale(-1 1) rotate(-90 0.5 1.5)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny})`}
        },
        hexagonal_a: function() {
          assign(this, new wallpapers.p1.hexagonal())
          this.edgeEnds = [[1,2]]
          this.edgeTfs = function () {let x=this.cpoint[0];
            return [['', `translate(-${x/2}  0.5)`, `scale(-1 1) translate(-${x} 0)`, `scale(-1 1) translate(-${x*1.5}  0.5)`]]}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2})`}
        },
        hexagonal_b: function() {
          assign(this, new wallpapers.cm.hexagonal_a())
          this.edgeTfs = function () {let x=this.cpoint[0];
            return [['', `translate(-${x/2}  0.5)`, `scale(1 -1) translate(0 -1)`, `scale(1 -1) translate(-${x/2}  -0.5)`]]}
        },
        rhombic_a: function() {
          assign(this, new wallpapers.cm.hexagonal_a())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        },
        rhombic_b: function() {
          assign(this, new wallpapers.cm.hexagonal_b())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      pmm: {},
      pmg: {
        square_a: function() { // vertical mirror
          assign(this, new wallpapers.p2.square())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => [['', 'rotate(180 1 0.5)', 'scale(-1 1) translate(-1 0)', 'scale(-1 1) rotate(180 0.5 0.5)'],
            ['', 'translate(0 -1)', 'scale(-1 1) translate(-1 0)', 'scale(-1 1) translate(-1 -1)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny}) rotate(${(d.nx)%2 * 180} 0.5 0.5)`}
        },
        square_b: function() { // horizontal mirror
          assign(this, new wallpapers.p2.square())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => [['', 'translate(-1 0)', 'scale(1 -1) translate(0 -1)', 'scale(1 -1) translate(-1 -1)'],
            ['', 'rotate(180 0.5 1)', 'scale(1 -1) translate(0 -1)', 'scale(1 -1) rotate(180 0.5 0.5)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny}) rotate(${(d.ny)%2 * 180} 0.5 0.5)`}
        },
        rectangular_a: function() { // vertical mirror
          assign(this, new wallpapers.p2.rectangular())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => {let x = this.cpoint[0];
            return [['', `rotate(180 ${x} 0.5)`, `scale(-1 1) translate(-${x} 0)`, `scale(-1 1) rotate(180 ${x/2} 0.5)`],
                    ['', 'translate(0 -1)', `scale(-1 1) translate(-${x} 0)`, `scale(-1 1) translate(-${x} -1)`]]}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]} ${d.ny}) rotate(${(d.nx)%2 * 180} ${this.cpoint[0]/2} 0.5)`}
        },
        rectangular_b: function() { // horizontal mirror
          assign(this, new wallpapers.p2.rectangular())
          this.edgeEnds = [[3,4],[4,5]]
          this.edgeTfs = () => {let x = this.cpoint[0];
            return [['', `translate(-${x} 0)`, `scale(1 -1) translate(0 -1)`, `scale(1 -1) translate(-${x} -1)`],
                    ['', `rotate(180 ${x/2} 1)`, `scale(1 -1) translate(0 -1)`, `scale(1 -1) rotate(180 ${x/2} 0.5)`]]}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]} ${d.ny}) rotate(${(d.ny)%2 * 180} ${this.cpoint[0]/2} 0.5)`}
        }
      },
      pgg: {
        square: function() {
          assign(this, new wallpapers.p1.square())
          this.edgeTfs = () => [['', 'translate(-1 1) scale(1 -1)'], ['', 'translate(1 -1) scale(-1 1)']]
          this.tf = function(d) {let xpar = d.nx%2; let ypar = d.ny%2;
            return `translate(${d.nx+ypar} ${d.ny+xpar}) scale(${1-2*ypar} ${1-2*xpar})`}
        },
        rectangular: function() {
          assign(this, new wallpapers.p1.rectangular())
          this.edgeTfs = () => [['', `translate(-${this.cpoint[0]} 1) scale(1 -1)`], ['', `translate(${this.cpoint[0]} -1) scale(-1 1)`]]
          this.tf = function(d) {let xpar = d.nx%2; let ypar = d.ny%2;
            return `translate(${(d.nx+ypar)*this.cpoint[0]} ${d.ny+xpar}) scale(${1-2*ypar} ${1-2*xpar})`}
        }
      },
      cmm: {
        square: function () {
          assign(this, new wallpapers.p2.square())
          this.edgeEnds = [[3,4]]
          this.edgeTfs = () => [['', 'rotate(180 0.5 0.5)', 'rotate(180 1 0.5)', 'translate(-1 0)',
            'scale(-1 1) rotate(-90 0.5 1.5)', 'scale(1 -1) rotate(-90)', ' scale(-1 1) rotate(-90 0 1)', 'scale(-1 1) rotate(90 0.5 -0.5)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny})`}
        },
        hexagonal: function() {
          assign(this, new wallpapers.p2.hexagonal())
          this.edgeEnds = [[3,4]]
          this.edgeTfs = () => {let x = this.cpoint[0]
            return [['', `rotate(180 ${x*0.75} 0.25)`, `translate(-${x/2} 0.5)`, `rotate(180 ${x/2} 0.5)`,
            `scale(-1 1) translate(-${x} 0)`, `scale(-1 1) translate(-${x*1.5} 0.5)`, `scale(-1 1) rotate(180 ${x*0.25} 0.25)`, `scale(-1 1) rotate(180 0 0.5)`]]}
          this.tf = function(d) {return `translate(${d.nx*this.cpoint[0]/2} ${d.ny + (d.nx%2)/2})`}
        },
        rhombic: function() {
          assign(this, new wallpapers.cmm.hexagonal())
          this.cmove = (x,y) => [x,0.5]; this.cmove.cursor = 'ew-resize'
        }
      },
      p4: {
        square: function() {
          assign(this, new wallpapers.cmm.square())
          this.edgeTfs = () => [['', 'rotate(90 0.5 0.5)', 'rotate(180 0.5 0.5)', 'rotate(270 0.5 0.5)',
            'rotate(180 1 0.5)', 'rotate(-90 1 1)', 'translate(-1, 0)', 'rotate(90 1 0)']]
        }
      },
      p4m: {},
      p4g: {
        square: function() {
          assign(this, new wallpapers.cmm.square())
          this.edgeTfs = () => [['', 'rotate(180 0.5 0.5)', 'rotate(-90 1 1)', 'rotate(90 1 0)',
            'scale(-1 1) translate(-1 0)', 'scale(-1 1) rotate(90 0.5 -0.5)', 'scale(-1 1) rotate(-90 0.5 1.5)', 'scale(-1 1) rotate(180 0 0.5)']]
          this.tf = function(d) {return `translate(${d.nx} ${d.ny}) rotate(${(d.nx+d.ny)%2 * 90} 0.5 0.5)`}
        }
      },
      //cpoint not used for hexagons and triangles, 'cause there's no point
      p3: {
        hexagonal_a: function() { // hexagons
          this.anchors = () => [[0, 0.25], [rt3/4, 0], [rt3/2, 0.25], [rt3/2, 0.75], [rt3/4, 1], [0, 0.75]]
          this.edgeEnds = [[2, 3]]
          this.edgeTfs = () => [['', `rotate(120 ${rt3/4} 0.5)`, `rotate(-120 ${rt3/4} 0.5)`,
            `rotate(120 ${rt3/2} 0.25)`, `translate(${-rt3/2} 0)`,`rotate(-120 ${rt3/2} 0.75)`]]
          this.tf = function(d) {return `translate(${rt3/2 * (d.nx + (d.ny%2)/2)} ${d.ny*0.75})`}
        },
        hexagonal_b: function() { // rhombuses
          assign(this, new wallpapers.p1.hexagonal())
          this.edgeTfs = () => [['', `rotate(120 ${rt3/2} 0)`], ['', `rotate(-120 ${rt3/2} 1)`]]
          this.tf = function (d) { // sorry about the mess..
            const y = d.nx%2 ? d.ny : d.ny%3 == 2 ? d.ny : d.ny + 1 - 2*d.ny%3
            if (y%3) return `translate(${d.nx*rt3/2} ${y - y%3 + (1-y%3%2)*1.5}) rotate(${(2-(d.nx+(y%3))%2)*120} ${rt3/2} 0.5)`
            else return `translate(${(d.nx+0.5)*rt3/2} ${y - (d.nx%2)*1.5 + 0.75})`
          }
        }
      },
      p3m1: {},
      p31m: {
        hexagonal_a: function() { // hexagons
          assign(this, new wallpapers.p3.hexagonal_a())
          this.anchors = () => [[    0, 0.25], [rt3/8, 0.125], [rt3/4, 0], [rt3*0.375, 0.125], [rt3/2, 0.25], [rt3/2, 0.5],
                                [rt3/2, 0.75], [rt3*0.375, 0.875], [rt3/4, 1], [rt3*0.125, 0.875], [    0, 0.75], [    0, 0.5]]
          this.edgeEnds = [[5, 6]]
          const oldEdgeTfs = this.edgeTfs()[0]
          this.edgeTfs = () => [oldEdgeTfs.concat(
            [`scale(-1, 1) rotate(180 ${rt3/4} 0.5)`, `scale(-1, 1) rotate(-60 ${rt3/4} 2)`, `scale(-1, 1) rotate(60 ${rt3/4} -1)`,
            `scale(-1, 1) rotate(180 0 0.5)`, `scale(-1, 1) rotate(-60 0 1.25)`, `scale(-1, 1) rotate(60 0 -0.25)`]
          )]
        },
        hexagonal_b: function() { // rhombuses
          assign(this, new wallpapers.p3.hexagonal_b())
          this.edgeEnds = [[2,3]]
          this.edgeTfs = () => [['', `rotate(-120 ${rt3/2} 1)`, `scale(-1, 1) rotate(60 ${rt3/2} -1)`, 'scale(-1, 1) rotate(180 0 0.5)']]
        }
      },
      p6: {
        hexagonal_a: function() { // hexagons
          assign(this, new wallpapers.p31m.hexagonal_a())
          oldEdgeTfs = this.edgeTfs()[0].slice(0,6)
          this.edgeTfs = () => [oldEdgeTfs.concat([
            `rotate(60 ${rt3/4} 0.5)`, `rotate(180 ${rt3/4} 0.5)`, `rotate(-60 ${rt3/4} 0.5)`,
            `rotate(60 ${rt3/2} -0.25)`, `rotate(180 ${rt3/2} 0.5)`, `rotate(-60 ${rt3/2} 1.25)`,
          ])]
        },
        hexagonal_b: function() { // rhombuses
          assign(this, new wallpapers.p31m.hexagonal_b())
          this.edgeTfs = () => [['', `rotate(-120 ${rt3/2} 1)`, `rotate(180 ${rt3/2} 0.5)`, `rotate(60 ${rt3} 0.5)`]]
        },
        hexagonal_c: function() { // triangles
          this.anchors = () => [[0, 0], [rt3/4, 0.25], [rt3/2, 0.5], [rt3/4, 0.75], [0, 1], [0, 0.5]]
          this.edgeEnds = [[2, 3]]
          this.edgeTfs = () => [['', `rotate(120 ${rt3*third/2} 0.5)`, `rotate(-120 ${rt3*third/2} 0.5)`,
            `rotate(60 ${rt3/2} 0.5)`, `rotate(180 ${rt3/4} 0.75)`, 'rotate(-60 0 1)']]
          this.tf = function(d) {return `translate(${d.nx*rt3/2} ${d.ny/2}) rotate(${((d.nx+d.ny)%2+1)*180} ${rt3/4} 0.5)`}
        }
      },
      p6m: {}
    }

    // for display
    const wpData = [
      [
        {constructor: wallpapers.p1.rectangular, symmetry: 'p1', lattice: 'Rectangular', hint: '[ o ]'},
        {constructor: wallpapers.p1.oblique, symmetry: 'p1', lattice: 'Oblique', hint: '\\ o \\'},
        {constructor: wallpapers.p1.rhombic, symmetry: 'p1', lattice: 'Rhombic', hint: '< o >'}
      ], [
        {constructor: wallpapers.p2.rectangular, symmetry: 'p2', lattice: 'Rectangular', hint: '[ ~ ]'},
        {constructor: wallpapers.p2.oblique, symmetry: 'p2', lattice: 'Oblique', hint: '\\ ~ \\'},
        {constructor: wallpapers.p2.rhombic, symmetry: 'p2', lattice: 'Rhombic', hint: '< ~ >'}
      ], [
        {constructor: wallpapers.pg.rectangular_a, symmetry: 'pg', lattice: 'Rectangular A', hint: '[ Z ]'},
        {constructor: wallpapers.pg.rectangular_b, symmetry: 'pg', lattice: 'Rectangular B', hint: '[ N ]'}
      ], [
        {constructor: wallpapers.cm.square, symmetry: 'cm', lattice: 'Square', hint: ' [/] '},
        {constructor: wallpapers.cm.rhombic_a, symmetry: 'cm', lattice: 'Rhombic A', hint: '< T >'},
        {constructor: wallpapers.cm.rhombic_b, symmetry: 'cm', lattice: 'Rhombic B', hint: '< E >'}
      ], [
        {constructor: wallpapers.pmg.rectangular_a, symmetry: 'pmg', lattice: 'Rectangular A', hint: '[ T ]'},
        {constructor: wallpapers.pmg.rectangular_b, symmetry: 'pmg', lattice: 'Rectangular B', hint: '[ E ]'}
      ], [
        {constructor: wallpapers.pgg.rectangular, symmetry: 'pgg', lattice: 'Rectangular', hint: '[ % ]'}
      ], [
        {constructor: wallpapers.cmm.square, symmetry: 'cmm', lattice: 'Square', hint: ' [X] '},
        {constructor: wallpapers.cmm.rhombic, symmetry: 'cmm', lattice: 'Rhombic', hint: '< X >'}
      ], [
        {constructor: wallpapers.p4.square, symmetry: 'p4', lattice: 'Square', hint: ' [+] '}
      ], [
        {constructor: wallpapers.p4g.square, symmetry: 'p4g', lattice: 'Square', hint: ' [H] '}
      ], [
        {constructor: wallpapers.p3.hexagonal_a, symmetry: 'p3', lattice: 'Hexagonal A', hint: '〔 〕'},
        {constructor: wallpapers.p3.hexagonal_b, symmetry: 'p3', lattice: 'Hexagonal B', hint: ' < > '}
      ], [
        {constructor: wallpapers.p31m.hexagonal_a, symmetry: 'p31m', lattice: 'Hexagonal A', hint: '〔Y〕'},
        {constructor: wallpapers.p31m.hexagonal_b, symmetry: 'p31m', lattice: 'Hexagonal B', hint: ' <Y> '}
      ], [
        {constructor: wallpapers.p6.hexagonal_a, symmetry: 'p6', lattice: 'Hexagonal A', hint: '〔*〕'},
        {constructor: wallpapers.p6.hexagonal_b, symmetry: 'p6', lattice: 'Hexagonal B', hint: ' <*> '},
        {constructor: wallpapers.p6.hexagonal_c, symmetry: 'p6', lattice: 'Hexagonal C', hint: ' |*> '}
      ]
    ]

    function tile(edges) {
      this.anchors = wallpaper.anchors()
      this.edges = edges || Array.from({length: wallpaper.edgeEnds.length}, () => [])
      this.fullEdges = function() {
        this.anchors = wallpaper.anchors()
        result = []
        for (let i=0; i<wallpaper.edgeEnds.length; i++) {
          result.push([this.anchors[wallpaper.edgeEnds[i][0]]].concat(this.edges[i], [this.anchors[wallpaper.edgeEnds[i][1]]]))
        }
        return result
      }
    }

    /****************\
    |*              *|
    |*  INITIATION  *|
    |*              *|
    \****************/

    const cpointDrag = d3.drag().on('start', updateJSON).on('drag', dragCpoint)
    const vertexDrag = d3.drag().on('start', updateJSON).on('drag', dragVertex)

    var wallpaper

    init()

    rerenderControls()

    d3.interval(function(t) { if (shouldRedraw) {
      if      (shouldRedraw == 3) restart()
      else if (shouldRedraw == 2) rerender()
      else                        reupdate()
      shouldRedraw = false
    }})

    /*************\
    |*           *|
    |*  DRAWING  *|
    |*           *|
    \*************/

    // initiate
    function init() {
      // symmetry sidebar
      wpDisplay = d3.select('#wpDisplay').datum(wpData)
      symmetryElements = wpDisplay.selectAll('tbody')
        .data(d => d).enter().insert('tbody',':last-child')
        .classed('wpGroup', true)
      latticeElements = symmetryElements.selectAll('label')
        .data(d => d).enter().append('label')
        .classed('wpVariant', true)
        .attr('for', d => d.symmetry+d.lattice.replace(/ /g, ''))
        .on('click', d => {wallpaper = new d.constructor(); restart()})
      latticeElements
        .append('input')
        .attr('type', 'radio')
        .attr('name', 'wallpaper')
        .attr('id', d => d.symmetry+d.lattice.replace(/ /g, ''))
      latticeElements
        .append('td')
        .classed('wpSymmetry', true)
        .append('label')
        .text(d => d.symmetry)
      latticeElements
        .append('td')
        .classed('wpLattice', true)
        .text(d => d.lattice)
      latticeElements
        .append('td')
        .classed('wpHint', true)
        .append('code')
        .text(d => d.hint)

      d3.select('#downloadSVG').on('click', downloadSVG)
      d3.select('#loadJSON').on('click', loadJSON)
      d3.select('#lockJSON').on('click', lockJSON)
      d3.select('#updateJSON').on('click', updateJSON)
      d3.select('#lockRendering').on('click', lockRendering)
      d3.select('#updateRendering').on('click', updateRendering)
      d3.select('#save').on('click', save)
      d3.select('#load').on('click', load)

      d3.selectAll('.help') 
        .datum(function(d,i) {let cL = this.classList; return cL[1] == 'help' ? cL[0] : cL[1]})
        .on('click', function(){ d3.event.whichTooltip = d3.select(this).select('.tooltip') })
      .append('div')
        .html(d => tips[d])
        .classed('tooltip', true)
        .on('click', ()=>{d3.event.stopPropagation()})

      d3.select(document).on('click', tooltipCheck)

      saveArea = d3.select('#saveArea')

      //big container svg elements
      svg = d3.select('#main')
        .style('width', width)
        .style('height', height)
      drawing = d3.select('#drawing')
        .attr('transform', `translate(${border} ${border}) scale(${scale})`)
      controls = d3.select('#controls')
        .attr('transform', `translate(${border} ${height - controlHeight - border}) scale(${controlHeight})`)

      //pick initial values
      latticeElements
        .filter(d => d.symmetry == 'cm' && d.lattice == 'Rhombic B')
        .select('input')
        .node().checked = true
      wallpaper = new wallpapers.cm.rhombic_b()

      // draw everything
      restart()
    }

    // TODO: add options to this
    function restart() {
      parqLocs = d3.cross(d3.range(nw), d3.range(nh), (a, b) => 
      ({
        nx: a,
        ny: b
      }))
      prototiles = [new tile(), new tile()]
      rerenderControls()
    }

    // create everything from scratch
    function rerender() {
      edgeGenerator = edgeGeneratorFactory()
      if (parqElements) parqElements.remove()
      parqElements = drawing.selectAll('g')
        .data(parqLocs).enter().append('g')
        .classed('parq', true)
        .attr('transform', wallpaper.tf.bind(wallpaper))
      edgeTfs = wallpaper.edgeTfs()
      if (edgeElements) edgeElements.remove()
      edgeElements = parqElements.selectAll('path')
        .data(loc => edgeData(edgeGenerator((clamp(1, loc.nx, nw-2)-1)/(nw-3)))).enter().append('path')
        .classed('edge', true)
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)
    }

    // when no new elements need to be inserted or removed, we can simply update them
    function reupdate() {
      edgeGenerator = edgeGeneratorFactory()
      if (cmoved) {
        parqElements.attr('transform', wallpaper.tf.bind(wallpaper))
        cmoved = false
      }
      edgeTfs = wallpaper.edgeTfs()
      edgeElements
        .data(loc => edgeData(edgeGenerator((clamp(1, loc.nx, nw-2)-1)/(nw-3))))
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)
    }

    /**************\
    |*            *|
    |*  CONTROLS  *|
    |*            *|
    \**************/

    function rerenderControls() {
      // "prototile" is the term for, not a tile, exactly, but the shape of a tile
      if (prototileElements) prototileElements.remove()
      prototileElements = controls.selectAll('g')
        .data(prototiles).enter().append('g')
        .attr('transform', (d,i,a) => `translate(${i*controlWidth/a.length + 0.25} 0.25) scale(0.5)`)


      // the edges. blue edges are "active" and can be manipulated. black edges are determined by blue edges
      if (ptEdgeElements) ptEdgeElements.remove()
      edgeTfs = wallpaper.edgeTfs()
      ptEdgeElements = prototileElements.selectAll('path')
        .data((pt, i) => edgeData(pt.fullEdges(), i)).enter().append('path')
        .classed('protoedge', true)
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)
      ptEdgeElements.filter(d => !d.tf)
        .classed('active', true)
        .on('mousedown', addVertex)

      // black points determined by the cpoint. at the ends of each edges, if the transforms are correct
      if(ptAnchorElements) ptAnchorElements.remove()
      ptAnchorElements = prototileElements.selectAll('circle.anchor')
        .data(pt => wallpaper.anchors()).enter().append('circle')
        .classed('anchor', true)
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])

      // orange point which controls the shape of the unit
      if (ptCpointElements) ptCpointElements.remove()
      if (wallpaper.cpoint) {
        ptCpointElements = prototileElements.selectAll('circle.cpoint')
          .data(pt => [wallpaper.cpoint]).enter().append('circle')
          .classed('cpoint', true)
          .classed('active', wallpaper.cmove.cursor!='default')
          .style('cursor', wallpaper.cmove.cursor)
          .attr('cx', wallpaper.cpoint[0])
          .attr('cy', wallpaper.cpoint[1])
          .call(cpointDrag)
      }

      // i'm just using vertices to mean the blue points used to manipulate the edges
      if(ptVertexWrappers) {
        ptVertexWrappers.remove()
        ptVertexElements.remove()
      }
      ptVertexWrappers = prototileElements.selectAll('g')
        .data((pt, i) => pt.edges.map(e => assign(e, {ptIndex: i}))).enter().append('g')
      ptVertexElements = ptVertexWrappers.selectAll('circle.vertex')
        .data(e => e.map(v => assign(v, {ptIndex: e.ptIndex}))).enter().append('circle')
        .each(function(d) {d.eIndex = ptVertexWrappers._groups[d.ptIndex].indexOf(this.parentNode)})
        .classed('vertex', true)
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])
        .on('contextmenu', deleteVertex)
        .on('click', 'selectVertex')
        .call(vertexDrag)

      if (liveDrawing) shouldRedraw = Math.max(2, shouldRedraw)
      if (liveSave) updateJSON()
    }

    function reupdateControls() {
      edgeTfs = wallpaper.edgeTfs()
      ptEdgeElements
        .data((pt, i) => edgeData(pt.fullEdges(), i))
        .attr('transform', d => d.tf)
        .attr('d', d => d.data)

      ptAnchorElements
        .data(pt => wallpaper.anchors())
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])

      if (wallpaper.cpoint) {
        ptCpointElements
          .attr('cx', wallpaper.cpoint[0])
          .attr('cy', wallpaper.cpoint[1])
      }

      ptVertexElements
        .attr('cx', d => d[0])
        .attr('cy', d => d[1])

      if (liveDrawing) shouldRedraw = Math.max(1, shouldRedraw)
      if (liveSave) updateJSON()
    }

    /***************\
    |*             *|
    |*  LISTENERS  *|
    |*             *|
    \***************/

    function dragVertex(d, i, g) {
      d[0] = d3.event.x
      d[1] = d3.event.y
      document.execCommand('undo')
      reupdateControls()
    }
    function dragCpoint(d, i, g) {
      wallpaper.cpoint.splice(0, 2, ...wallpaper.cmove(d3.event.x, d3.event.y))
      cmoved = true
      document.execCommand('undo')
      reupdateControls()
    }

    function addVertex(d, i, g) {
      const point = clientToLocal(d3.event, this)
      const dist = distanceAlongPath(this, clientToLocal(d3.event, this))
      const edge = prototiles[d.ptIndex].fullEdges()[i]
      let j = 0
      while (distanceAlongPath(this, edge[j]) < dist && j < edge.length) j++
      for (let k=0; k < prototiles.length; k++) {
        let fulledge = prototiles[k].fullEdges()[i]
        let newVertex = k == d.ptIndex?
          [point.x, point.y]:
          d3.interpolate(fulledge[j-1],fulledge[j])(0.5)
        prototiles[k].edges[i].splice(j-1,0,newVertex)
      }
      rerenderControls()
      let newVertex = ptVertexWrappers._groups[d.ptIndex][i].children[j-1]
      d3.select(newVertex).dispatch('mouseup')
      // <selection>.dispatch creates a custom event which doesn't have the "view" property
      // d3.drag requires event.view, so we do this "properly" instead
      let mouseDown = new MouseEvent('mousedown',
        {view: window, bubbles: true, cancelable: true}
      );
      newVertex.dispatchEvent(mouseDown)
    }
    function deleteVertex(d, i, g) {
      let e = d3.event
      e.preventDefault()
      for (let k=0; k < prototiles.length; k++) {
        prototiles[k].edges[d.eIndex].splice(i, 1)
      }
      rerenderControls()
    }

    function tooltipCheck() {
      let tooltip = d3.event.whichTooltip, wasAlreadyDisplayed = true
      if (tooltip) wasAlreadyDisplayed = tooltip.style('display') == 'block'
      d3.selectAll('.tooltip').style('display', 'none')
      if (!wasAlreadyDisplayed) tooltip.style('display', 'block')
    }

    function downloadSVG() {
      let prefix = '<?xml version="1.0" standalone="no"?>\n<?xml-stylesheet type="text/css" href="style8.css"?>\n'
      +'<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
      +'<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink">\n'
      let blob = new Blob(
        [prefix, drawing.node().outerHTML.replace(/(\.\d{4})\d*/g, '$1'),
        d3.select('style#parqStyle').node().outerHTML, '\n</svg>'], {type: 'image/svg+xml'})
      console.log(blob)
      saveAs(blob, 'parquet.svg')
    }

    function loadJSON() {
      deformation = JSON.parse(saveArea.node().value)
      console.log()
      wallpaper = new wallpapers[deformation.symmetry][deformation.lattice]()
      if (wallpaper.cpoint) wallpaper.cpoint = wallpaper.cmove(...deformation.cpoint)
      prototiles = deformation.tiles.map(t => new tile(t))
      rerenderControls()
    }
    function lockJSON() {
      if (liveSave) {
        liveSave = false
        this.innerText = "Unlock JSON"
      } else {
        liveSave = true
        this.innerText = "Lock JSON"
      }
    }
    function updateJSON(t) {
      let textarea = saveArea.node()
      textarea.select()
      supportsCommand = document.execCommand('insertText', false, saveString())
      if (!supportsCommand) textarea.value = saveString()
    }

    function lockRendering() {
      if (liveDrawing) {
        liveDrawing = false
        this.innerText = "Unlock Rendering"
        this.nextElementSibling.removeAttribute('disabled')
      } else {
        liveDrawing = true
        this.innerText = "Lock Rendering"
        this.nextElementSibling.setAttribute('disabled', '')
      }
    }
    function updateRendering() {
      reupdate()
    }

    function save() {
      
    }
    function load() {
      
    }

    /***************\
    |*             *|
    |*  UTILITIES  *|
    |*             *|
    \***************/

    function edgeGeneratorFactory() {
      return d3.piecewise(d3.interpolate, prototiles.map(t => t.fullEdges()))
    }

    function clientToLocal(e, svgEl) {
      let point = svg.node().createSVGPoint()
      point.x = e.clientX; point.y = e.clientY
      point = point.matrixTransform(svgEl.getScreenCTM().inverse())
      return point
    }

    function distanceAlongPath(path, point) {
      const length = path.getTotalLength()
      const delta = length/1024
      let i = 0
      let best, bestDist = length**2

      if (Array.isArray(point)) {
        let temppoint = svg.node().createSVGPoint()
        temppoint.x = point[0]; temppoint.y = point[1]
        point = temppoint
      }

      while (i < 1024 && bestDist > delta**2) {
        let point2 = path.getPointAtLength(i*delta)
        let dist = (point.x-point2.x)**2 + (point.y-point2.y)**2
        if (dist > (64*delta)**2) i+=64
        else if (dist > (8*delta)**2) i+=8
        else i += 1
        if (dist < bestDist) {
          bestDist = dist
          best = i
        }
      }
      return best*delta
    }

    function edgeData(edges, ptIndex=-1) {
      edges = edges.map(edgeHelper)
      let result = []
      for (let i=0; i<wallpaper.edgeEnds.length; i++) {
        for (let j=0; j<edgeTfs[i].length; j++) {
          result.push({
            tf: edgeTfs[i][j],
            data: edges[i],
            ptIndex: ptIndex
          })
        }
      }
      return result
    }

    // creates JSON representation of all relevant data
    function saveString() {
      let lattice = wallpaper.constructor;
      let symmetry
      for (let sym in wallpapers) {
        if (wallpapers[sym][lattice.name] === lattice) {
          symmetry = sym; break
        }
      }

      // arrow function does 1.7320508075688772 -> " 1.7321"
      result = JSON.stringify(
        {symmetry: symmetry, lattice: lattice.name, cpoint: wallpaper.cpoint, tiles: prototiles.map(t => t.edges)},
        (key, val) => val.toFixed? val.toFixed(4).replace(/[0.](?=0*$)/g,' ').replace(/^(?=\d)/, ' ') : val,
        2
      )
      result = result
        .replace(/"(-? ?\d+(\.\d*)? *)"/g, '$1')                              // quoted numbers to actual numbers
        .replace(/( *)\[\n *?(-? ?\d.*)\n *?(-? ?\d.*)\n *\]/g, '$1[$2 $3]')  // each point to single line
        .replace(/( {8}.*\n)(?= {8})/g,'$1~').replace(/\n~ */g, ' ')          // all points in each edge to same line
        .replace(/\n {6}\[\n {8}(.*)\n {6}\]/g, '\n      [$1]')   // each edge to single line
        .replace(/( {6})(\[\]),\n(?=\1\2)/g, '$1$2, ')            // consecutive empty edges to same line
        .replace(/([^\n ]) {7}/g, '$1 ')                          // get rid of extra spaces from previous step
        .replace(/\n {4}\[\n {6}(.*)\n {4}\]/g, '\n    [$1]')     // "small" tiles to single line
        .replace(/  \],\n *\[\n/g, '  ], [\n')                    // "],[" between "big" arrays to single line
        .replace(/{\n(  .*)\n ( .*)\n ( .*)/, '{\n$1$2$3')        // non-"tiles" props to single line
      // I know it's a lot of junk but it makes the JSONs look super nice so I don't care
      return result
    }

    function clamp (a, val, b) {
      return Math.max(a, Math.min(val, b))
    }

    function indexOf(that, e) {
      return Array.prototype.indexOf.call(that, e)
    }
  </script>
</body>
</html>
